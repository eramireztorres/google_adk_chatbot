{"id": "18cbb167-4f44-4bac-971e-76a15ed75dd1", "code": "from __future__ import annotations\n\nimport logging\nimport os\nimport subprocess\nimport sys\nimport tempfile\nfrom pathlib import Path\nfrom typing import Dict\n\nfrom dotenv import load_dotenv\n\nfrom google.adk.agents import LlmAgent\nfrom google.adk.models.lite_llm import LiteLlm\nfrom google.adk.tools.agent_tool import AgentTool\nfrom google.adk.tools.function_tool import FunctionTool\nfrom google.adk.tools.mcp_tool.mcp_toolset import MCPToolset\nfrom google.adk.tools.mcp_tool.mcp_session_manager import SseConnectionParams\nfrom google.adk.tools.tool_context import ToolContext\n\nload_dotenv()\n\n\ndef _configure_logging() -> None:\n    log_dir = Path(__file__).resolve().parent / \"logs\"\n    log_dir.mkdir(parents=True, exist_ok=True)\n    log_file = log_dir / \"adk.log\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        handlers=[\n            logging.FileHandler(log_file, encoding=\"utf-8\"),\n            logging.StreamHandler(),\n        ],\n    )\n\n\n_configure_logging()\n\n\ndef _resolve_llm_model() -> str | LiteLlm:\n    provider = os.getenv(\"ADK_LLM_PROVIDER\", \"openai\").strip().lower()\n    model = os.getenv(\"ADK_LLM_MODEL\", \"gpt-4.1-mini\").strip()\n    if provider == \"openai\":\n        return LiteLlm(model=f\"openai/{model}\")\n    return model\n\n\ndef _rag_mcp_url() -> str:\n    return os.getenv(\"RAG_MCP_URL\", \"http://127.0.0.1:8000/sse\").strip()\n\n\n\n\ndef run_python_snippet(code: str, tool_context: ToolContext) -> Dict[str, object]:\n    \"\"\"\n    Run a small Python snippet in the current environment to validate imports or\n    simple instantiations. Avoid long-running operations.\n    \"\"\"\n    if not code or not code.strip():\n        return {\"ok\": False, \"error\": \"No code provided.\"}\n\n    with tempfile.NamedTemporaryFile(\"w\", suffix=\".py\", delete=False) as handle:\n        handle.write(code)\n        path = handle.name\n\n    try:\n        result = subprocess.run(\n            [sys.executable, path],\n            capture_output=True,\n            text=True,\n            timeout=10,\n        )\n    except subprocess.TimeoutExpired:\n        return {\"ok\": False, \"error\": \"Execution timed out.\"}\n    finally:\n        try:\n            os.unlink(path)\n        except OSError:\n            pass\n\n    result_payload = {\n        \"ok\": result.returncode == 0,\n        \"returncode\": result.returncode,\n        \"stdout\": result.stdout.strip(),\n        \"stderr\": result.stderr.strip(),\n    }\n    return result_payload\n\n\ndef _build_rag_agent(model: str | LiteLlm) -> LlmAgent:\n    rag_toolset = MCPToolset(\n        connection_params=SseConnectionParams(\n            url=_rag_mcp_url(),\n            timeout=300,\n        )\n    )\n    return LlmAgent(\n        name=\"RagAgent\",\n        model=model,\n        instruction=(\n            \"Answer user questions about Google ADK using the MCP RAG tool. \"\n            \"If the question has multiple concepts, split into 2-3 focused subqueries, \"\n            \"call the MCP tool for each, and synthesize a single answer. \"\n            \"If the user asks for code, include a Python code block. \"\n            \"Only use ADK APIs that appear in the provided documentation. \"\n            \"Do not invent convenience methods like agent.chat/agent.run/agent.invoke. \"\n            \"Use the Runner/Invocation patterns shown in ADK docs for execution. \"\n            \"Do not include commented-out calls to non-existent methods; omit the call entirely.\"\n        ),\n        tools=[rag_toolset],\n    )\n\n\ndef _build_root_agent(model: str | LiteLlm) -> LlmAgent:\n    rag_agent = _build_rag_agent(model)\n    rag_tool = AgentTool(agent=rag_agent)\n    check_tool = FunctionTool(func=run_python_snippet)\n\n    return LlmAgent(\n        name=\"RootAgent\",\n        model=model,\n        instruction=(\n            \"You are the main coordinator. For every user query, call the RAG tool. \"\n            \"If the RagAgent response includes a Python code block, run a minimal \"\n            \"import/instantiation check using the code-check tool before responding. \"\n            \"If the check fails, reformulate the query and call the RAG tool again, \"\n            \"then re-check once before responding. \"\n            \"Do not return commented-out calls to non-existent methods.\"\n        ),\n        tools=[rag_tool, check_tool],\n    )\n\n\nroot_agent = _build_root_agent(_resolve_llm_model())\n", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1769298877.8903775, "iteration_found": 0, "metrics": {"combined_score": 0.535304036140442, "latency": 38.02929719289144, "artifacts": {"details": [{"query": "Write a complete Python script to create and run a simple ADK agent named 'SimpleAgent' using the 'gpt-4.1-nano' model. The agent should have the instruction 'You are a helpful assistant.' and respond to the user message 'Hello'. Use InMemorySessionService for the session.", "score": 0.55, "latency": 19.38530969619751, "code_extracted": true, "exec_success": false, "keyword_match": 0.5}, {"query": "Create a Python script that defines a custom tool function `calculate_area(radius: int) -> dict` which returns the area of a circle. Initialize an ADK Agent with this tool and run it with the query 'Calculate area of circle with radius 5'.", "score": 0.5, "latency": 26.569865703582764, "code_extracted": true, "exec_success": false, "keyword_match": 0.3333333333333333}, {"query": "Write a Python script to create a SequentialAgent in ADK that chains two sub-agents: `step1_agent` and `step2_agent`. `step1_agent` should generate a topic, and `step2_agent` should write a poem about it. Run the sequential agent.", "score": 0.5800000000000001, "latency": 18.542023181915283, "code_extracted": true, "exec_success": false, "keyword_match": 0.6}, {"query": "Write a Python script that configures an ADK Agent with a specific `GenerateContentConfig` setting the temperature to 0.7. Run the agent with a simple prompt.", "score": 0.45, "latency": 23.256146907806396, "code_extracted": true, "exec_success": false, "keyword_match": 0.16666666666666666}, {"query": "Create a Python script that defines a `before_agent_callback` to print 'Agent Starting' before the agent runs. Attach this callback to an ADK Agent and execute it.", "score": 0.76, "latency": 47.44441866874695, "code_extracted": true, "exec_success": true, "keyword_match": 0.2}, {"query": "Write a Python script defining a custom agent class `MyCustomAgent` that inherits from `BaseAgent`. Implement the `_run_async_impl` method to yield a single text event 'Custom Run'. Run an instance of this agent.", "score": 0.6, "latency": 92.97801899909973, "code_extracted": true, "exec_success": false, "keyword_match": 0.6666666666666666}], "avg_latency": 38.02929719289144}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}