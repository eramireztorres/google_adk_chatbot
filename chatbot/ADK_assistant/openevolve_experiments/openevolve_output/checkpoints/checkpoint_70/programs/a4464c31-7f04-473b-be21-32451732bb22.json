{"id": "a4464c31-7f04-473b-be21-32451732bb22", "code": "from __future__ import annotations\n\nimport logging\nimport os\nimport subprocess\nimport sys\nimport tempfile\nfrom pathlib import Path\nfrom typing import Dict\n\nfrom dotenv import load_dotenv\n\nfrom google.adk.agents import LlmAgent\nfrom google.adk.models.lite_llm import LiteLlm\nfrom google.adk.tools.agent_tool import AgentTool\nfrom google.adk.tools.function_tool import FunctionTool\nfrom google.adk.tools.mcp_tool.mcp_toolset import MCPToolset\nfrom google.adk.tools.mcp_tool.mcp_session_manager import SseConnectionParams\nfrom google.adk.tools.tool_context import ToolContext\n\nload_dotenv()\n\n\ndef _configure_logging() -> None:\n    log_dir = Path(__file__).resolve().parent / \"logs\"\n    log_dir.mkdir(parents=True, exist_ok=True)\n    log_file = log_dir / \"adk.log\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        handlers=[\n            logging.FileHandler(log_file, encoding=\"utf-8\"),\n            logging.StreamHandler(),\n        ],\n    )\n\n\n_configure_logging()\n\n\n\n# Validating and resolving configuration\ndef _resolve_llm_model() -> str | LiteLlm:\n    provider = os.getenv(\"ADK_LLM_PROVIDER\", \"openai\").strip().lower()\n    model = os.getenv(\"ADK_LLM_MODEL\", \"gpt-4.1-mini\").strip()\n    if provider == \"openai\":\n        return LiteLlm(model=f\"openai/{model}\")\n    return model\n\ndef _rag_mcp_url() -> str:\n    return os.getenv(\"RAG_MCP_URL\", \"http://127.0.0.1:8000/sse\").strip()\n\nmodel = _resolve_llm_model()\nrag_mcp_url = _rag_mcp_url()\n\n# 1. Define the RAG Agent\nrag_toolset = MCPToolset(\n    connection_params=SseConnectionParams(\n        url=rag_mcp_url,\n        timeout=300,\n    )\n)\n\nfrom google.adk.agents import SequentialAgent, LoopAgent, LlmAgent\nfrom google.adk.tools.agent_tool import AgentTool\nfrom google.adk.tools.function_tool import FunctionTool\nfrom google.adk.tools.tool_context import ToolContext\n\n# Define specialized sub-agents for planning, querying, code check, and synthesis in a SequentialAgent pipeline\nplanning_agent = LlmAgent(\n    name=\"PlanningAgent\",\n    model=model,\n    instruction=(\n        \"You are a planning agent specialized in analyzing user questions about Google ADK. \"\n        \"If the question involves multiple distinct concepts, split it into 2-3 focused and concise subqueries. \"\n        \"Return only a valid JSON array of strings representing these subqueries. \"\n        \"If only one concept is present, return a single-element array with that query.\"\n        \"Do not add any explanations or extra text outside the JSON array.\"\n    ),\n    output_key=\"subqueries\",\n)\n\nquery_agent = LlmAgent(\n    name=\"QueryAgent\",\n    model=model,\n    instruction=(\n        \"Answer each focused query about Google ADK by using the MCP RAG toolset. \"\n        \"If the user requests code, include Python code blocks with correct syntax. \"\n        \"Use only the ADK APIs explicitly documented. \"\n        \"Do not invent or mention convenience methods like agent.chat, agent.run, or agent.invoke. \"\n        \"Demonstrate usage following the Runner/Invocation patterns as shown in the official ADK documentation. \"\n        \"Output only the answer content and code blocks, without extra commentary.\"\n    ),\n    tools=[rag_toolset],\n    output_key=\"rag_response\",\n)\n\ncode_check_agent = LlmAgent(\n    name=\"CodeCheckAgent\",\n    model=model,\n    instruction=(\n        \"Analyze the rag_response output and extract all Python code blocks. \"\n        \"For each code block, call the code-check tool to validate correct imports, syntax, and instantiations. \"\n        \"If any code block fails validation, respond strictly with 'CHECK_FAILED'. \"\n        \"If all code blocks pass, respond strictly with 'CHECK_PASSED'. \"\n        \"Do not add any other text or explanations.\"\n    ),\n    tools=[],\n    output_key=\"code_check_result\",\n)\n\nsynthesizer_agent = LlmAgent(\n    name=\"SynthesizerAgent\",\n    model=model,\n    instruction=(\n        \"Produce the final concise answer by synthesizing the rag_response content. \"\n        \"If code_check_result is 'CHECK_PASSED', include all valid Python code blocks inline. \"\n        \"If code_check_result is 'CHECK_FAILED', respond with a short message indicating that you are retrying due to code validation failure, \"\n        \"but do not include code blocks. \"\n        \"Ensure the response is self-contained and user-ready, without internal agent notes.\"\n    ),\n    output_key=\"final_answer\",\n)\n\nbase_rag_agent = SequentialAgent(\n    name=\"RagAgentPipeline\",\n    sub_agents=[planning_agent, query_agent, code_check_agent, synthesizer_agent],\n    description=\"Pipeline: plan query, check code, synthesize answer\",\n)\n\n# Wrap the pipeline in a LoopAgent to retry once if code check fails\nrag_agent = LoopAgent(\n    name=\"RagAgentWithRetry\",\n    sub_agents=[base_rag_agent],\n    max_iterations=2,\n)\n\n\n# 2. Define the Code Check Tool\ndef run_python_snippet(code: str, tool_context: ToolContext) -> Dict[str, object]:\n    \"\"\"\n    Run a small Python snippet in the current environment to validate imports or\n    simple instantiations. Avoid long-running operations.\n    Escalate early to exit LoopAgent early if validation fails.\n    \"\"\"\n    if not code or not code.strip():\n        return {\"ok\": False, \"error\": \"No code provided.\"}\n\n    # Sanitize code to prevent dangerous imports or calls (basic heuristic)\n    restricted_keywords = [\"import os\", \"import sys\", \"subprocess\", \"open(\", \"exec(\", \"eval(\"]\n    for keyword in restricted_keywords:\n        if keyword in code:\n            tool_context.actions.escalate = True\n            return {\"ok\": False, \"error\": f\"Use of restricted keyword '{keyword}' in code snippet.\"}\n\n    # Enforce max code length for safety and responsiveness\n    if len(code) > 1000:\n        return {\"ok\": False, \"error\": \"Code snippet too long.\"}\n\n    with tempfile.NamedTemporaryFile(\"w\", suffix=\".py\", delete=False) as handle:\n        handle.write(code)\n        path = handle.name\n\n    try:\n        result = subprocess.run(\n            [sys.executable, path],\n            capture_output=True,\n            text=True,\n            timeout=10,\n        )\n    except subprocess.TimeoutExpired:\n        tool_context.actions.escalate = True\n        return {\"ok\": False, \"error\": \"Execution timed out.\"}\n    finally:\n        try:\n            os.unlink(path)\n        except OSError:\n            pass\n\n    result_payload = {\n        \"ok\": result.returncode == 0,\n        \"returncode\": result.returncode,\n        \"stdout\": result.stdout.strip(),\n        \"stderr\": result.stderr.strip(),\n    }\n    if not result_payload[\"ok\"]:\n        tool_context.actions.escalate = True\n    return result_payload\n\n\n# 3. Define the Root Agent\nrag_tool = AgentTool(agent=rag_agent)\ncheck_tool = FunctionTool(func=run_python_snippet)\n\nroot_agent = LlmAgent(\n    name=\"RootAgent\",\n    model=model,\n    instruction=(\n        \"You are the main coordinator agent. For each user query, invoke the RagAgentWithRetry loop workflow to plan, query, check code, and synthesize a final answer. \"\n        \"If code validation fails, retry the loop once to improve the answer. \"\n        \"Only respond with the final, validated answer content. \"\n        \"Do not include commented-out code or calls to non-existent methods. \"\n        \"Be concise and user-friendly.\"\n    ),\n    tools=[AgentTool(agent=rag_agent), FunctionTool(func=run_python_snippet)],\n    output_key=\"final_answer\",\n)\n\n", "language": "python", "parent_id": "f8bb76d4-66ef-4fb9-8d50-f35dc8e97463", "generation": 3, "timestamp": 1769340462.8474572, "iteration_found": 0, "metrics": {"combined_score": 0.5628158141771952, "latency": 32.18418582280477, "artifacts": {"details": [{"query": "Write a complete Python script to create and run a simple ADK agent named 'SimpleAgent' using the 'gpt-4.1-nano' model. The agent should have the instruction 'You are a helpful assistant.' and respond to the user message 'Hello'. Use InMemorySessionService for the session.", "score": 0.55, "latency": 31.465389490127563, "code_extracted": true, "exec_success": false, "keyword_match": 0.5}, {"query": "Create a Python script that defines a custom tool function `calculate_area(radius: int) -> dict` which returns the area of a circle. Initialize an ADK Agent with this tool and run it with the query 'Calculate area of circle with radius 5'.", "score": 0.5, "latency": 33.366450548172, "code_extracted": true, "exec_success": false, "keyword_match": 0.3333333333333333}, {"query": "Write a Python script to create a SequentialAgent in ADK that chains two sub-agents: `step1_agent` and `step2_agent`. `step1_agent` should generate a topic, and `step2_agent` should write a poem about it. Run the sequential agent.", "score": 0.64, "latency": 37.73653507232666, "code_extracted": true, "exec_success": false, "keyword_match": 0.8}, {"query": "Write a Python script that configures an ADK Agent with a specific `GenerateContentConfig` setting the temperature to 0.7. Run the agent with a simple prompt.", "score": 0.4, "latency": 27.99392795562744, "code_extracted": true, "exec_success": false, "keyword_match": 0.0}, {"query": "Create a Python script that defines a `before_agent_callback` to print 'Agent Starting' before the agent runs. Attach this callback to an ADK Agent and execute it.", "score": 0.5800000000000001, "latency": 38.44411253929138, "code_extracted": true, "exec_success": false, "keyword_match": 0.6}, {"query": "Write a Python script defining a custom agent class `MyCustomAgent` that inherits from `BaseAgent`. Implement the `_run_async_impl` method to yield a single text event 'Custom Run'. Run an instance of this agent.", "score": 0.8999999999999999, "latency": 24.09869933128357, "code_extracted": true, "exec_success": true, "keyword_match": 0.6666666666666666}], "avg_latency": 32.18418582280477}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 10 lines with 12 lines\nChange 2: Replace 13 lines with 14 lines\nChange 3: Replace 11 lines with 13 lines\nChange 4: Replace 10 lines with 12 lines\nChange 5: Replace 13 lines with 13 lines\nChange 6: Replace 45 lines with 49 lines", "parent_metrics": {"combined_score": 0.3859895883401234, "latency": 80.67707832654317, "artifacts": {"details": [{"query": "Write a complete Python script to create and run a simple ADK agent named 'SimpleAgent' using the 'gpt-4.1-nano' model. The agent should have the instruction 'You are a helpful assistant.' and respond to the user message 'Hello'. Use InMemorySessionService for the session.", "score": 0.55, "latency": 48.696109771728516, "code_extracted": true, "exec_success": false, "keyword_match": 0.5}, {"query": "Create a Python script that defines a custom tool function `calculate_area(radius: int) -> dict` which returns the area of a circle. Initialize an ADK Agent with this tool and run it with the query 'Calculate area of circle with radius 5'.", "score": 0.5, "latency": 40.1099693775177, "code_extracted": true, "exec_success": false, "keyword_match": 0.3333333333333333}, {"query": "Write a Python script to create a SequentialAgent in ADK that chains two sub-agents: `step1_agent` and `step2_agent`. `step1_agent` should generate a topic, and `step2_agent` should write a poem about it. Run the sequential agent.", "score": 0.64, "latency": 92.47493577003479, "code_extracted": true, "exec_success": false, "keyword_match": 0.8}, {"query": "Write a Python script that configures an ADK Agent with a specific `GenerateContentConfig` setting the temperature to 0.7. Run the agent with a simple prompt.", "score": 0.0, "latency": 90.27741742134094, "code_extracted": false, "exec_success": false, "keyword_match": 0.0}, {"query": "Create a Python script that defines a `before_agent_callback` to print 'Agent Starting' before the agent runs. Attach this callback to an ADK Agent and execute it.", "score": 0.46, "latency": 179.8089394569397, "code_extracted": true, "exec_success": false, "keyword_match": 0.2}, {"query": "Write a Python script defining a custom agent class `MyCustomAgent` that inherits from `BaseAgent`. Implement the `_run_async_impl` method to yield a single text event 'Custom Run'. Run an instance of this agent.", "score": 0.65, "latency": 32.69509816169739, "code_extracted": true, "exec_success": false, "keyword_match": 0.8333333333333334}], "avg_latency": 80.67707832654317}}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}