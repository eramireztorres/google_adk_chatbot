{"id": "165fc62c-aee2-4580-8934-3a9bea4c3a33", "code": "import os\nimport re\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_core.documents import Document\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.vector_store = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 800\n        self.chunk_overlap = 300\n        self.top_k = 7\n        self.temperature = 0.3\n        \n        # Load env\n        load_dotenv(os.path.join(os.path.dirname(__file__), '.env'))\n        self._initialize_system()\n\n    def _initialize_system(self):\n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        docs = []\n        if os.path.exists(self.docs_dir):\n            for root, _, files in os.walk(self.docs_dir):\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply enhanced chunking strategy with markdown header splitting\n                        chunks = self._chunk_document(text_content, file_path)\n                        docs.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        # Vector Store (FAISS)\n        if docs:\n            self.vector_store = FAISS.from_documents(docs, embeddings)\n        else:\n            self.vector_store = None\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n\n    def _chunk_document(self, text: str, source: str) -> List[Document]:\n        \"\"\"\n        Enhanced chunking:\n        - Split by markdown headers to preserve section semantics.\n        - Within sections, split by code fences.\n        - Handle code density to treat code blocks atomically or as text.\n        \"\"\"\n        CODE_FENCE_RE = re.compile(r\"```([a-zA-Z0-9_+-]*)\\n(.*?)\\n```\", re.DOTALL)\n        CODE_SIGNAL_RE = re.compile(r\"\\b(def|class|import|from|package|func|public|private|return|if|for|while|var|let|const|func|type|struct)\\b\")\n        HEADER_RE = re.compile(r\"^(#{1,3})\\s+(.*)\", re.MULTILINE)\n\n        def _is_navigation_chunk(txt: str) -> bool:\n            return \"Skip to main content\" in txt and \"Navigation\" in txt\n            \n        def _code_density(txt: str) -> float:\n            lines = [line.strip() for line in txt.splitlines() if line.strip()]\n            if not lines: return 0.0\n            code_like = sum(1 for line in lines if CODE_SIGNAL_RE.search(line))\n            return code_like / len(lines)\n\n        chunks = []\n\n        # Split document by headers (level 1 to 3)\n        header_splits = []\n        last_idx = 0\n        for m in HEADER_RE.finditer(text):\n            header_splits.append((m.start(), m.group(0)))\n        header_splits.append((len(text), None))  # sentinel\n\n        for i in range(len(header_splits)-1):\n            start = header_splits[i][0]\n            end = header_splits[i+1][0]\n            section_text = text[start:end].strip()\n            if not section_text or _is_navigation_chunk(section_text):\n                continue\n\n            # Within section, split by code fences\n            cursor = 0\n            for match in CODE_FENCE_RE.finditer(section_text):\n                cstart, cend = match.span()\n                if cstart > cursor:\n                    pre_text = section_text[cursor:cstart]\n                    if pre_text.strip():\n                        self._make_text_chunks(pre_text, source, chunks, self.chunk_size, self.chunk_overlap)\n                lang = (match.group(1) or \"\").strip()\n                code = match.group(2)\n                if code.strip():\n                    fence = f\"```{lang}\\n{code}\\n```\"\n                    density = _code_density(code)\n                    if density > 0.2:\n                        chunks.append(Document(\n                            page_content=fence,\n                            metadata={\"source\": source, \"type\": \"code\", \"lang\": lang, \"density\": density}\n                        ))\n                    else:\n                        self._make_text_chunks(fence, source, chunks, self.chunk_size, self.chunk_overlap)\n                cursor = cend\n            tail = section_text[cursor:]\n            if tail.strip():\n                self._make_text_chunks(tail, source, chunks, self.chunk_size, self.chunk_overlap)\n\n        return chunks\n\n    def _make_text_chunks(self, text: str, source: str, chunks_list: List[Document], size: int, overlap: int):\n        # Improved rolling window split to respect sentence boundaries when possible\n        import nltk\n        try:\n            nltk.data.find('tokenizers/punkt')\n        except LookupError:\n            nltk.download('punkt')\n        from nltk.tokenize import sent_tokenize\n\n        sentences = sent_tokenize(text)\n        current_chunk = \"\"\n        for sent in sentences:\n            if len(current_chunk) + len(sent) + 1 > size:\n                if current_chunk:\n                    chunks_list.append(Document(page_content=current_chunk.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n                    # Overlap: include last overlap chars in new chunk start\n                    overlap_text = current_chunk[-overlap:] if overlap < len(current_chunk) else current_chunk\n                    current_chunk = overlap_text + \" \" + sent\n                else:\n                    # Single sentence longer than chunk size, just append\n                    chunks_list.append(Document(page_content=sent.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n                    current_chunk = \"\"\n            else:\n                current_chunk += \" \" + sent\n        if current_chunk.strip():\n            chunks_list.append(Document(page_content=current_chunk.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.vector_store:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        retrieved = self.vector_store.similarity_search(query_str, k=self.top_k)\n        contexts = [d.page_content for d in retrieved]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in retrieved]\n\n        # Re-rank by simple heuristic: prefer chunks containing query keywords\n        query_terms = set(re.findall(r\"\\w+\", query_str.lower()))\n        scored = []\n        for doc in retrieved:\n            content_lower = doc.page_content.lower()\n            match_count = sum(1 for term in query_terms if term in content_lower)\n            scored.append((match_count, doc))\n        scored.sort(key=lambda x: x[0], reverse=True)\n        top_docs = [doc for _, doc in scored[:self.top_k]]\n\n        context_block = \"\"\n        for i, doc in enumerate(top_docs):\n            src = doc.metadata.get(\"source\", \"unknown\")\n            context_block += f\"Source {i+1} ({src}):\\n{doc.page_content}\\n\\n\"\n\n        # Generation prompt improved for clarity and faithfulness\n        prompt = (\n            f\"You are an expert assistant answering questions about Google ADK documentation.\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\"\n            \"Answer strictly based on the context above. \"\n            \"If code examples are present, use them to support your answer. \"\n            \"Do not fabricate information and be concise.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        return {\"answer\": res.content, \"contexts\": [doc.page_content for doc in top_docs]}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "af10b932-3d5b-45bf-a513-6d41dd6c21b0", "generation": 1, "timestamp": 1769111396.2241566, "iteration_found": 1, "metrics": {"combined_score": 0.5375, "num_samples": 8, "raw_scores": [0.25, 1.0, 0.3625]}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 4 lines with 4 lines\nChange 2: Replace 24 lines with 24 lines\nChange 3: Replace 53 lines with 62 lines\nChange 4: Replace 13 lines with 26 lines\nChange 5: Replace 22 lines with 35 lines", "parent_metrics": {"combined_score": 0.6875, "num_samples": 8, "raw_scores": [0.75, 0.875, 0.4375]}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert RAG system optimizer. Your goal is to improve the RAG pipeline to maximize retrieval accuracy and answer quality on the Google ADK documentation.\n\nThe initial program has a basic chunking strategy and retrieval setup. You have full control to evolve:\n\n1. **Chunking Strategy**: Modify `_chunk_document` and `_make_text_chunks`. Experiment with:\n   - Code fence handling (density checks, language detection).\n   - Header-based splitting (markdown structure).\n   - Semantic chunking.\n   - Varying chunk sizes and overlaps.\n\n2. **Retrieval**: Modify `RAGSystem.__init__` and `query`. Experiment with:\n   - `top_k` (k) parameter.\n   - Vector store choice (prefer FAISS for indexing and retrieval).\n   - Retrieval strategy (similarity vs. MMR) and relevance thresholds if you implement them.\n   - Optional FAISS persistence (save/load local index) and relevance score filtering.\n    - Hybrid search (if you can implement keyword search to combine with vector search).\n    - Re-ranking (if feasible with available libraries/APIs, or simple heuristic re-ranking).\n    - Query expansion or rewriting before retrieval.\n   \n3. **Generation**: Modify the prompt in `query`.\n\n**Constraints**:\n- You MUST maintain the `evaluate_rag(docs_path, query)` function signature and return dictionary specific keys (`answer`, `contexts`).\n- You MUST keep the `RAGSystem` class structure (or equivalent) to ensure `evaluate_rag` works.\n- Code must be robust and handle potential parsing errors resiliently.\n\nThe evaluator uses \"Evidently\" to compute a combined score of Correctness, Faithfulness, Relevance, etc. Maximizing this score is your primary objective.\n", "user": "# Current Program Information\n- Fitness: 0.6875\n- Feature coordinates: combined_score=0.69\n- Focus areas: - Fitness unchanged at 0.6875\n- Exploring combined_score=0.69 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.6875, num_samples: 8.0000, raw_scores: [0.75, 0.875, 0.4375]\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.6875)\n```python\nimport os\nimport re\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_core.documents import Document\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.vector_store = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1000\n        self.chunk_overlap = 200\n        self.top_k = 5\n        self.temperature = 0.7\n        \n        # Load env\n        load_dotenv(os.path.join(os.path.dirname(__file__), '.env'))\n        self._initialize_system()\n\n    def _initialize_system(self):\n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        docs = []\n        if os.path.exists(self.docs_dir):\n            for root, _, files in os.walk(self.docs_dir):\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        docs.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        # Vector Store (FAISS)\n        if docs:\n            self.vector_store = FAISS.from_documents(docs, embeddings)\n        else:\n            self.vector_store = None\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n\n    def _chunk_document(self, text: str, source: str) -> List[Document]:\n        \"\"\"\n        Ad-hoc chunking logic adapted from run_ingestion.py.\n        \"\"\"\n        # Regex patterns from run_ingestion.py\n        CODE_FENCE_RE = re.compile(r\"```([a-zA-Z0-9_+-]*)\\n(.*?)\\n```\", re.DOTALL)\n        CODE_SIGNAL_RE = re.compile(r\"\\b(def|class|import|from|package|func|public|private|return|if|for|while)\\b\")\n        \n        def _is_navigation_chunk(txt: str) -> bool:\n            return \"Skip to main content\" in txt and \"Navigation\" in txt\n            \n        def _code_density(txt: str) -> float:\n            lines = [line.strip() for line in txt.splitlines() if line.strip()]\n            if not lines: return 0.0\n            code_like = sum(1 for line in lines if CODE_SIGNAL_RE.search(line))\n            return code_like / len(lines)\n\n        chunks = []\n        cursor = 0\n        \n        # Split by code fences first\n        for match in CODE_FENCE_RE.finditer(text):\n            start, end = match.span()\n            if start > cursor:\n                pre_text = text[cursor:start]\n                if pre_text.strip():\n                    if not _is_navigation_chunk(pre_text):\n                        self._make_text_chunks(pre_text, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            lang = (match.group(1) or \"\").strip()\n            code = match.group(2)\n            \n            # Logic to keep code blocks atomic\n            if code.strip():\n                fence = f\"```{lang}\\n{code}\\n```\"\n                density = _code_density(code)\n                # If high density or explicitly fenced, treat as code\n                if density > 0.2:\n                     chunks.append(Document(\n                         page_content=fence, \n                         metadata={\"source\": source, \"type\": \"code\", \"lang\": lang, \"density\": density}\n                     ))\n                else:\n                    # Treat as text if low density code\n                    self._make_text_chunks(fence, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            cursor = end\n            \n        tail = text[cursor:]\n        if tail.strip() and not _is_navigation_chunk(tail):\n            self._make_text_chunks(tail, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n        return chunks\n\n    def _make_text_chunks(self, text: str, source: str, chunks_list: List[Document], size: int, overlap: int):\n        # Standard rolling window split for text parts\n        if len(text) <= size:\n            chunks_list.append(Document(page_content=text, metadata={\"source\": source, \"type\": \"text\"}))\n            return\n            \n        start = 0\n        while start < len(text):\n            end = min(start + size, len(text))\n            chunk_text = text[start:end]\n            chunks_list.append(Document(page_content=chunk_text, metadata={\"source\": source, \"type\": \"text\"}))\n            start += size - overlap\n            if start >= len(text): break\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.vector_store:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        retrieved = self.vector_store.similarity_search(query_str, k=self.top_k)\n        contexts = [d.page_content for d in retrieved]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in retrieved]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            context_block += f\"Source {i+1} ({src}):\\n{content}\\n\\n\"\n\n        # Generation\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Answer the question based strictly on the context provided. \"\n            \"If the context contains code examples, prioritize them in your answer.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.6875), Performs well on num_samples (8.0000), Performs well on raw_scores ([0.75, 0.875, 0.4375])\n\n\n\n# Current Program\n```python\nimport os\nimport re\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_core.documents import Document\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.vector_store = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1000\n        self.chunk_overlap = 200\n        self.top_k = 5\n        self.temperature = 0.7\n        \n        # Load env\n        load_dotenv(os.path.join(os.path.dirname(__file__), '.env'))\n        self._initialize_system()\n\n    def _initialize_system(self):\n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        docs = []\n        if os.path.exists(self.docs_dir):\n            for root, _, files in os.walk(self.docs_dir):\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        docs.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        # Vector Store (FAISS)\n        if docs:\n            self.vector_store = FAISS.from_documents(docs, embeddings)\n        else:\n            self.vector_store = None\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n\n    def _chunk_document(self, text: str, source: str) -> List[Document]:\n        \"\"\"\n        Ad-hoc chunking logic adapted from run_ingestion.py.\n        \"\"\"\n        # Regex patterns from run_ingestion.py\n        CODE_FENCE_RE = re.compile(r\"```([a-zA-Z0-9_+-]*)\\n(.*?)\\n```\", re.DOTALL)\n        CODE_SIGNAL_RE = re.compile(r\"\\b(def|class|import|from|package|func|public|private|return|if|for|while)\\b\")\n        \n        def _is_navigation_chunk(txt: str) -> bool:\n            return \"Skip to main content\" in txt and \"Navigation\" in txt\n            \n        def _code_density(txt: str) -> float:\n            lines = [line.strip() for line in txt.splitlines() if line.strip()]\n            if not lines: return 0.0\n            code_like = sum(1 for line in lines if CODE_SIGNAL_RE.search(line))\n            return code_like / len(lines)\n\n        chunks = []\n        cursor = 0\n        \n        # Split by code fences first\n        for match in CODE_FENCE_RE.finditer(text):\n            start, end = match.span()\n            if start > cursor:\n                pre_text = text[cursor:start]\n                if pre_text.strip():\n                    if not _is_navigation_chunk(pre_text):\n                        self._make_text_chunks(pre_text, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            lang = (match.group(1) or \"\").strip()\n            code = match.group(2)\n            \n            # Logic to keep code blocks atomic\n            if code.strip():\n                fence = f\"```{lang}\\n{code}\\n```\"\n                density = _code_density(code)\n                # If high density or explicitly fenced, treat as code\n                if density > 0.2:\n                     chunks.append(Document(\n                         page_content=fence, \n                         metadata={\"source\": source, \"type\": \"code\", \"lang\": lang, \"density\": density}\n                     ))\n                else:\n                    # Treat as text if low density code\n                    self._make_text_chunks(fence, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            cursor = end\n            \n        tail = text[cursor:]\n        if tail.strip() and not _is_navigation_chunk(tail):\n            self._make_text_chunks(tail, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n        return chunks\n\n    def _make_text_chunks(self, text: str, source: str, chunks_list: List[Document], size: int, overlap: int):\n        # Standard rolling window split for text parts\n        if len(text) <= size:\n            chunks_list.append(Document(page_content=text, metadata={\"source\": source, \"type\": \"text\"}))\n            return\n            \n        start = 0\n        while start < len(text):\n            end = min(start + size, len(text))\n            chunk_text = text[start:end]\n            chunks_list.append(Document(page_content=chunk_text, metadata={\"source\": source, \"type\": \"text\"}))\n            start += size - overlap\n            if start >= len(text): break\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.vector_store:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        retrieved = self.vector_store.similarity_search(query_str, k=self.top_k)\n        contexts = [d.page_content for d in retrieved]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in retrieved]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            context_block += f\"Source {i+1} ({src}):\\n{content}\\n\\n\"\n\n        # Generation\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Answer the question based strictly on the context provided. \"\n            \"If the context contains code examples, prioritize them in your answer.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, combined_score\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n        self.chunk_size = 1000\n        self.chunk_overlap = 200\n        self.top_k = 5\n        self.temperature = 0.7\n=======\n        self.chunk_size = 800\n        self.chunk_overlap = 300\n        self.top_k = 7\n        self.temperature = 0.3\n>>>>>>> REPLACE\n\n# Reasoning:\n# - Smaller chunk size (800) with larger overlap (300) can capture more context continuity and semantic boundaries, improving retrieval relevance.\n# - Increasing top_k to 7 improves retrieval breadth, potentially enhancing answer quality.\n# - Lower temperature (0.3) encourages more factual and focused generation, improving faithfulness and correctness.\n\n<<<<<<< SEARCH\n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        docs = []\n        if os.path.exists(self.docs_dir):\n            for root, _, files in os.walk(self.docs_dir):\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        docs.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        # Vector Store (FAISS)\n        if docs:\n            self.vector_store = FAISS.from_documents(docs, embeddings)\n        else:\n            self.vector_store = None\n=======\n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        docs = []\n        if os.path.exists(self.docs_dir):\n            for root, _, files in os.walk(self.docs_dir):\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply enhanced chunking strategy with markdown header splitting\n                        chunks = self._chunk_document(text_content, file_path)\n                        docs.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        # Vector Store (FAISS)\n        if docs:\n            self.vector_store = FAISS.from_documents(docs, embeddings)\n        else:\n            self.vector_store = None\n>>>>>>> REPLACE\n\n# Explanation:\n# No change here except a comment indicating markdown header splitting will be integrated in _chunk_document.\n\n<<<<<<< SEARCH\n    def _chunk_document(self, text: str, source: str) -> List[Document]:\n        \"\"\"\n        Ad-hoc chunking logic adapted from run_ingestion.py.\n        \"\"\"\n        # Regex patterns from run_ingestion.py\n        CODE_FENCE_RE = re.compile(r\"```([a-zA-Z0-9_+-]*)\\n(.*?)\\n```\", re.DOTALL)\n        CODE_SIGNAL_RE = re.compile(r\"\\b(def|class|import|from|package|func|public|private|return|if|for|while)\\b\")\n        \n        def _is_navigation_chunk(txt: str) -> bool:\n            return \"Skip to main content\" in txt and \"Navigation\" in txt\n            \n        def _code_density(txt: str) -> float:\n            lines = [line.strip() for line in txt.splitlines() if line.strip()]\n            if not lines: return 0.0\n            code_like = sum(1 for line in lines if CODE_SIGNAL_RE.search(line))\n            return code_like / len(lines)\n\n        chunks = []\n        cursor = 0\n        \n        # Split by code fences first\n        for match in CODE_FENCE_RE.finditer(text):\n            start, end = match.span()\n            if start > cursor:\n                pre_text = text[cursor:start]\n                if pre_text.strip():\n                    if not _is_navigation_chunk(pre_text):\n                        self._make_text_chunks(pre_text, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            lang = (match.group(1) or \"\").strip()\n            code = match.group(2)\n            \n            # Logic to keep code blocks atomic\n            if code.strip():\n                fence = f\"```{lang}\\n{code}\\n```\"\n                density = _code_density(code)\n                # If high density or explicitly fenced, treat as code\n                if density > 0.2:\n                     chunks.append(Document(\n                         page_content=fence, \n                         metadata={\"source\": source, \"type\": \"code\", \"lang\": lang, \"density\": density}\n                     ))\n                else:\n                    # Treat as text if low density code\n                    self._make_text_chunks(fence, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n            cursor = end\n            \n        tail = text[cursor:]\n        if tail.strip() and not _is_navigation_chunk(tail):\n            self._make_text_chunks(tail, source, chunks, self.chunk_size, self.chunk_overlap)\n            \n        return chunks\n=======\n    def _chunk_document(self, text: str, source: str) -> List[Document]:\n        \"\"\"\n        Enhanced chunking:\n        - Split by markdown headers to preserve section semantics.\n        - Within sections, split by code fences.\n        - Handle code density to treat code blocks atomically or as text.\n        \"\"\"\n        CODE_FENCE_RE = re.compile(r\"```([a-zA-Z0-9_+-]*)\\n(.*?)\\n```\", re.DOTALL)\n        CODE_SIGNAL_RE = re.compile(r\"\\b(def|class|import|from|package|func|public|private|return|if|for|while|var|let|const|func|type|struct)\\b\")\n        HEADER_RE = re.compile(r\"^(#{1,3})\\s+(.*)\", re.MULTILINE)\n\n        def _is_navigation_chunk(txt: str) -> bool:\n            return \"Skip to main content\" in txt and \"Navigation\" in txt\n            \n        def _code_density(txt: str) -> float:\n            lines = [line.strip() for line in txt.splitlines() if line.strip()]\n            if not lines: return 0.0\n            code_like = sum(1 for line in lines if CODE_SIGNAL_RE.search(line))\n            return code_like / len(lines)\n\n        chunks = []\n\n        # Split document by headers (level 1 to 3)\n        header_splits = []\n        last_idx = 0\n        for m in HEADER_RE.finditer(text):\n            header_splits.append((m.start(), m.group(0)))\n        header_splits.append((len(text), None))  # sentinel\n\n        for i in range(len(header_splits)-1):\n            start = header_splits[i][0]\n            end = header_splits[i+1][0]\n            section_text = text[start:end].strip()\n            if not section_text or _is_navigation_chunk(section_text):\n                continue\n\n            # Within section, split by code fences\n            cursor = 0\n            for match in CODE_FENCE_RE.finditer(section_text):\n                cstart, cend = match.span()\n                if cstart > cursor:\n                    pre_text = section_text[cursor:cstart]\n                    if pre_text.strip():\n                        self._make_text_chunks(pre_text, source, chunks, self.chunk_size, self.chunk_overlap)\n                lang = (match.group(1) or \"\").strip()\n                code = match.group(2)\n                if code.strip():\n                    fence = f\"```{lang}\\n{code}\\n```\"\n                    density = _code_density(code)\n                    if density > 0.2:\n                        chunks.append(Document(\n                            page_content=fence,\n                            metadata={\"source\": source, \"type\": \"code\", \"lang\": lang, \"density\": density}\n                        ))\n                    else:\n                        self._make_text_chunks(fence, source, chunks, self.chunk_size, self.chunk_overlap)\n                cursor = cend\n            tail = section_text[cursor:]\n            if tail.strip():\n                self._make_text_chunks(tail, source, chunks, self.chunk_size, self.chunk_overlap)\n\n        return chunks\n>>>>>>> REPLACE\n\n# Explanation:\n# - Added splitting by markdown headers (levels 1-3) to preserve section semantics, which improves chunk coherence and retrieval relevance.\n# - Within each section, previous code fence splitting and code density logic is preserved.\n# - This approach better respects document structure to improve contextual retrieval.\n\n<<<<<<< SEARCH\n    def _make_text_chunks(self, text: str, source: str, chunks_list: List[Document], size: int, overlap: int):\n        # Standard rolling window split for text parts\n        if len(text) <= size:\n            chunks_list.append(Document(page_content=text, metadata={\"source\": source, \"type\": \"text\"}))\n            return\n            \n        start = 0\n        while start < len(text):\n            end = min(start + size, len(text))\n            chunk_text = text[start:end]\n            chunks_list.append(Document(page_content=chunk_text, metadata={\"source\": source, \"type\": \"text\"}))\n            start += size - overlap\n            if start >= len(text): break\n=======\n    def _make_text_chunks(self, text: str, source: str, chunks_list: List[Document], size: int, overlap: int):\n        # Improved rolling window split to respect sentence boundaries when possible\n        import nltk\n        try:\n            nltk.data.find('tokenizers/punkt')\n        except LookupError:\n            nltk.download('punkt')\n        from nltk.tokenize import sent_tokenize\n\n        sentences = sent_tokenize(text)\n        current_chunk = \"\"\n        for sent in sentences:\n            if len(current_chunk) + len(sent) + 1 > size:\n                if current_chunk:\n                    chunks_list.append(Document(page_content=current_chunk.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n                    # Overlap: include last overlap chars in new chunk start\n                    overlap_text = current_chunk[-overlap:] if overlap < len(current_chunk) else current_chunk\n                    current_chunk = overlap_text + \" \" + sent\n                else:\n                    # Single sentence longer than chunk size, just append\n                    chunks_list.append(Document(page_content=sent.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n                    current_chunk = \"\"\n            else:\n                current_chunk += \" \" + sent\n        if current_chunk.strip():\n            chunks_list.append(Document(page_content=current_chunk.strip(), metadata={\"source\": source, \"type\": \"text\"}))\n>>>>>>> REPLACE\n\n# Explanation:\n# - Use sentence tokenization to chunk text more naturally at sentence boundaries, improving semantic coherence.\n# - Overlap is applied at chunk boundaries by including trailing overlap characters from previous chunk.\n# - This reduces chunks breaking mid-sentence, improving retrieval and answer quality.\n\n<<<<<<< SEARCH\n        if not self.vector_store:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        retrieved = self.vector_store.similarity_search(query_str, k=self.top_k)\n        contexts = [d.page_content for d in retrieved]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in retrieved]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            context_block += f\"Source {i+1} ({src}):\\n{content}\\n\\n\"\n\n        # Generation\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Answer the question based strictly on the context provided. \"\n            \"If the context contains code examples, prioritize them in your answer.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        return {\"answer\": res.content, \"contexts\": contexts}\n=======\n        if not self.vector_store:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        retrieved = self.vector_store.similarity_search(query_str, k=self.top_k)\n        contexts = [d.page_content for d in retrieved]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in retrieved]\n\n        # Re-rank by simple heuristic: prefer chunks containing query keywords\n        query_terms = set(re.findall(r\"\\w+\", query_str.lower()))\n        scored = []\n        for doc in retrieved:\n            content_lower = doc.page_content.lower()\n            match_count = sum(1 for term in query_terms if term in content_lower)\n            scored.append((match_count, doc))\n        scored.sort(key=lambda x: x[0], reverse=True)\n        top_docs = [doc for _, doc in scored[:self.top_k]]\n\n        context_block = \"\"\n        for i, doc in enumerate(top_docs):\n            src = doc.metadata.get(\"source\", \"unknown\")\n            context_block += f\"Source {i+1} ({src}):\\n{doc.page_content}\\n\\n\"\n\n        # Generation prompt improved for clarity and faithfulness\n        prompt = (\n            f\"You are an expert assistant answering questions about Google ADK documentation.\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\"\n            \"Answer strictly based on the context above. \"\n            \"If code examples are present, use them to support your answer. \"\n            \"Do not fabricate information and be concise.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        return {\"answer\": res.content, \"contexts\": [doc.page_content for doc in top_docs]}\n>>>>>>> REPLACE\n\n# Explanation:\n# - Added a simple re-ranking heuristic: sort retrieved docs by number of query terms contained.\n#   This helps prioritize more relevant chunks.\n# - Improved generation prompt to be clearer about strict context usage, discouraging hallucinations.\n# - Return contexts consistent with reranked top documents.\n# - This should improve faithfulness, relevance, and correctness scores."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}