{"id": "18637c3f-078a-4e46-ad89-cfebd99ff59c", "code": "import os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import re\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract all consecutive header lines at start of section for richer header_path\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                else:\n                    if header_lines:\n                        content_start = i\n                        break\n            header_path = \" > \".join(header_lines) if header_lines else \"\"\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n\n        # --- AD-HOC RERANKING: prioritize docs containing query keywords in header_path and code blocks ---\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n        def score_doc(d):\n            score = 0\n            # Boost if any query word in header_path metadata with higher weight\n            header_path = d.metadata.get(\"header_path\", \"\").lower()\n            for word in query_words:\n                if word in header_path:\n                    score += 2.5\n            # Boost docs with code blocks (``` present) more strongly\n            if '```' in d.page_content:\n                score += 1.5\n            # Boost longer docs (up to +1.2)\n            score += min(len(d.page_content) / 800, 1.2)\n            # Additional boost for matching unique query words in content (weighted 0.6 per match)\n            content_lower = d.page_content.lower()\n            content_words = set(re.findall(r'\\w+', content_lower))\n            common = query_words.intersection(content_words)\n            score += 0.6 * len(common)\n            # Small penalty for overly short docs to avoid less informative chunks\n            if len(d.page_content) < 200:\n                score -= 0.5\n            return score\n\n        docs = sorted(docs, key=score_doc, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation precision\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n\n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_info = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_suffix = f\" [{header_info}]\" if header_info else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_suffix}:\\n{content}\\n\\n\"\n\n        # Generation prompt with chain-of-thought hint and mandatory terms check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify and list key terms or definitions from the question that must be included in the answer. \"\n            \"Step 2: Then provide a detailed answer strictly based on the context. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"Include relevant detail while staying faithful to the context. \"\n            \"If the answer is not found in the context, respond with 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "23ffef86-fc8a-450b-a682-9e51475556d6", "generation": 4, "timestamp": 1769535204.515571, "iteration_found": 41, "metrics": {"combined_score": 0.47507142857142853, "num_samples": 10, "raw_scores": [0.29, 0.38000000000000006, 0.605, 0.635, 0.28, 0.697857142857143, 0.6599999999999999, 0.43785714285714283, 0.42000000000000004, 0.345]}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 23 lines with 26 lines\nChange 2: Replace 16 lines with 17 lines\nChange 3: Replace 43 lines with 43 lines", "parent_metrics": {"combined_score": 0.5100714285714285, "num_samples": 10, "raw_scores": [0.295, 0.37, 0.6200000000000001, 0.6050000000000001, 0.5700000000000001, 0.7328571428571429, 0.6599999999999999, 0.46785714285714286, 0.42999999999999994, 0.35]}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert RAG system optimizer. Your goal is to improve the RAG pipeline to maximize retrieval accuracy and answer quality on the Google ADK documentation.\n\nThe initial program has a hybrid retrieval setup (FAISS + BM25), recursive chunking, and a FlashRank reranker. You have full control to evolve:\n\n1. **Advanced Chunking**: Modify `_chunk_document`. Experiment with:\n   - `RecursiveCharacterTextSplitter` separators (e.g., adding markdown header support like `\\n# `, `\\n## `).\n   - Context-aware splitting: Adding metadata like \"header_path\" to chunks to help the LLM understand hierarchy.\n   - Small-to-Big retrieval: Chunking small but returning parents.\n\n2. **Retrieval & Reranking**: Modify `RAGSystem.__init__` and `query`. Experiment with:\n   - **Ad-Hoc Reordering**: In `query`, use Python to sort `docs` by length, metadata, or keyword presence.\n   - **Ensemble Weights**: Optimize the balance between semantic (FAISS) and keyword (BM25) search.\n   \n**Verified Import Laws (USE ONLY THESE PATHS)**:\n- `from langchain_community.document_transformers import LongContextReorder`\n- `from langchain_classic.retrievers.document_compressors import EmbeddingsFilter`\n- `from langchain_text_splitters import RecursiveCharacterTextSplitter`\n\n**Forbidden Imports (DO NOT USE - CAUSE CRASHES)**:\n- `FlashrankRerank`\n- `CohereRerank`\n- `ContextualCompressionRetriever`\n- `CrossEncoder`\n\n**Performance & Architecture Laws**:\n- **No Neural Rerankers**: Do NOT use ONNX, Torch, or external reranking models. Use pure Python logic only.\n- **Variable Safety**: Always check your loop variables.\n\n3. **Generation Precision**: Modify the prompt in `query`. Experiment with:\n   - Context compression: Re-summarizing retrieved chunks before passing to the final LLM call.\n   - Thinking/CoT steps: Asking the LLM to analyze the context for mandatory terms before answering.\n\n**Example of lightweight ad-hoc reranking**:\n```python\ndef query(self, query):\n    docs = self.retriever.invoke(query)\n    # Custom logic: Prioritize \"Reference\" docs\n    docs.sort(key=lambda d: \"Reference\" in d.metadata.get(\"source\", \"\"), reverse=True)\n```\n\n**Constraints**:\n- You MUST maintain the `evaluate_rag(docs_path, query)` function signature and return dictionary keys: `answer`, `contexts`.\n- You MUST keep the `RAGSystem` class structure.\n", "user": "# Current Program Information\n- Fitness: 0.5101\n- Feature coordinates: combined_score=0.51\n- Focus areas: - Fitness unchanged at 0.5101\n- Exploring combined_score=0.51 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 28 lines with 43 lines\nChange 2: Replace 46 lines with 52 lines\n- Metrics: combined_score: 0.5101, num_samples: 10.0000, raw_scores: [np.float64(0.295), np.float64(0.37), np.float64(0.6200000000000001), np.float64(0.6050000000000001), np.float64(0.5700000000000001), np.float64(0.7328571428571429), np.float64(0.6599999999999999), np.float64(0.46785714285714286), np.float64(0.42999999999999994), np.float64(0.35)]\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 52 lines with 61 lines\nChange 2: Replace 58 lines with 61 lines\n- Metrics: combined_score: 0.5119, num_samples: 10.0000, raw_scores: [np.float64(0.265), np.float64(0.6000000000000001), np.float64(0.485), np.float64(0.64), np.float64(0.6100000000000001), np.float64(0.7564285714285715), np.float64(0.655), np.float64(0.33785714285714286), np.float64(0.5), np.float64(0.27)]\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 12 lines with 43 lines\nChange 2: Replace 27 lines with 44 lines\n- Metrics: combined_score: 0.5342, num_samples: 10.0000, raw_scores: [np.float64(0.48500000000000004), np.float64(0.48), np.float64(0.645), np.float64(0.655), np.float64(0.4700000000000001), np.float64(0.6578571428571429), np.float64(0.77), np.float64(0.4492857142857143), np.float64(0.45999999999999996), np.float64(0.27)]\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5342)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract header path from the start lines of the section content\n            lines = section_doc.page_content.splitlines()\n            header_path = \"\"\n            for line in lines:\n                if line.strip().startswith(\"#\"):\n                    header_path = line.strip()\n                    break\n            content_start = 0\n            if header_path:\n                try:\n                    content_start = lines.index(header_path) + 1\n                except Exception:\n                    content_start = 0\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING ---\n        # Rerank retrieved docs by boosting those with header_path containing \"Reference\" or \"API\"\n        def rerank_key(doc):\n            header_path = doc.metadata.get(\"header_path\", \"\").lower()\n            score = 0\n            if \"reference\" in header_path:\n                score += 2\n            if \"api\" in header_path:\n                score += 1.5\n            # Also boost longer chunks moderately (up to 1 point)\n            score += min(len(doc.page_content) / 1000.0, 1.0)\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n        \n        # Limit to top rerank_top_n docs for prompt context to reduce noise\n        limited_docs = docs[:self.rerank_top_n]\n        \n        contexts = [d.page_content for d in limited_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in limited_docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = limited_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        # Generation prompt with chain-of-thought and mandatory terms analysis\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify any mandatory terms, definitions, or key concepts related to the question in the context.\\n\"\n            \"Step 2: Based strictly on the context, provide a detailed answer. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"Include relevant detail while staying faithful. \"\n            \"If the answer is not found, say 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5342), Performs well on num_samples (10.0000), Performs well on raw_scores ([np.float64(0.48500000000000004), np.float64(0.48), np.float64(0.645), np.float64(0.655), np.float64(0.4700000000000001), np.float64(0.6578571428571429), np.float64(0.77), np.float64(0.4492857142857143), np.float64(0.45999999999999996), np.float64(0.27)])\n\n### Program 2 (Score: 0.5119)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # Improved header-aware chunking with markdown header separators including level 5 headers\n        # Also add support for small-to-big retrieval: keep mapping from small chunks to their parent header chunk\n        \n        # First split by even larger header sections to capture big context\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 5,  # Larger chunk to isolate header sections\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \"]\n        )\n        header_docs = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Then chunk each header section into smaller chunks with overlap and add rich header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for hd in header_docs:\n            lines = hd.page_content.splitlines()\n            header_lines = []\n            content_start_idx = 0\n            # Accumulate multiple header levels for richer context path, keep levels 1-5\n            for i, line in enumerate(lines):\n                stripped = line.strip()\n                if stripped.startswith(\"#\"):\n                    # Limit header level to 5 hashes max for path\n                    hashes = len(stripped) - len(stripped.lstrip('#'))\n                    if hashes <= 5:\n                        header_lines.append(stripped)\n                        content_start_idx = i + 1\n                else:\n                    if header_lines:\n                        break\n            header_path = \" > \".join(header_lines)\n            content = \"\\n\".join(lines[content_start_idx:])\n            if not content.strip():\n                content = hd.page_content\n\n            # Create smaller chunks with header_path metadata\n            chunks = small_splitter.create_documents(\n                [content],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            # Add parent chunk (header_doc) as well to enable small-to-big retrieval if needed\n            # Mark parent chunk with header_path and source, content is full header_doc content\n            parent_doc = hd\n            # Add header_path explicitly for parent_doc metadata (in case missing)\n            parent_meta = dict(parent_doc.metadata)\n            parent_meta[\"header_path\"] = header_path\n            parent_doc = parent_doc.__class__(page_content=parent_doc.page_content, metadata=parent_meta)\n            all_chunks.extend(chunks)\n            all_chunks.append(parent_doc)  # Append parent chunk for retrieval completeness\n\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING EXAMPLE (Lightweight) ---\n        # Boost chunks with \"Reference\" or \"Tutorial\" in source metadata and presence of query keywords in chunk\n        def rerank_key(doc):\n            src = doc.metadata.get(\"source\", \"\").lower()\n            score = 0\n            if \"reference\" in src:\n                score += 3\n            if \"tutorial\" in src:\n                score += 1.5\n            # Prefer longer chunks moderately up to 1.5 points\n            score += min(len(doc.page_content) / 800, 1.5)\n            # Boost if query keywords appear in chunk (case-insensitive)\n            query_lower = query_str.lower()\n            query_words = set(query_lower.split())\n            content_lower = doc.page_content.lower()\n            # Count unique query words in content\n            count = sum(1 for w in query_words if w in content_lower)\n            score += count * 1.2  # Stronger weight for keyword presence\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation prompt to reduce noise\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        # Generation with chain-of-thought style instruction and mandatory term check\n        # Add context compression by summarizing retrieved chunks before final prompt\n        summary_prompt = (\n            f\"Summarize the following context chunks concisely focusing on information relevant to the question: {query_str}\\n\\n\"\n        )\n        # For safety, limit context chunks for summarization\n        summary_input = \"\\n---\\n\".join(contexts[:self.rerank_top_n])\n        summary_prompt += summary_input + \"\\n\\nSummary:\"\n\n        summary_res = self.llm.invoke(summary_prompt)\n        compressed_context = summary_res.content\n\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context Summary:\\n{compressed_context}\\n\\n\"\n            \"Before answering, analyze the context carefully for any mandatory terms or definitions related to the question. \"\n            \"Then provide a detailed answer strictly based on this summary. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"If the answer is not found in the context, respond with 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5119), Performs well on num_samples (10.0000), Performs well on raw_scores ([np.float64(0.265), np.float64(0.6000000000000001), np.float64(0.485), np.float64(0.64), np.float64(0.6100000000000001), np.float64(0.7564285714285715), np.float64(0.655), np.float64(0.33785714285714286), np.float64(0.5), np.float64(0.27)])\n\n### Program 3 (Score: 0.5101)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import re\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract all header lines at start of section for richer header_path\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                else:\n                    if header_lines:\n                        content_start = i\n                        break\n            header_path = \" > \".join(header_lines) if header_lines else \"\"\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n\n        # --- AD-HOC RERANKING: prioritize docs containing query keywords in header_path ---\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n        def score_doc(d):\n            score = 0\n            # Boost if any query word in header_path metadata\n            header_path = d.metadata.get(\"header_path\", \"\").lower()\n            for word in query_words:\n                if word in header_path:\n                    score += 2\n            # Also boost docs with code blocks (``` present)\n            if '```' in d.page_content:\n                score += 1\n            # Boost longer docs (up to +1)\n            score += min(len(d.page_content) / 1000, 1)\n            # Additional boost for matching query words in content (weighted 0.5 per match)\n            content_lower = d.page_content.lower()\n            content_words = set(re.findall(r'\\w+', content_lower))\n            common = query_words.intersection(content_words)\n            score += 0.5 * len(common)\n            return score\n\n        docs = sorted(docs, key=score_doc, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation precision\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n\n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_info = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_suffix = f\" [{header_info}]\" if header_info else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_suffix}:\\n{content}\\n\\n\"\n\n        # Generation prompt with chain-of-thought hint and mandatory terms check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify and list key terms from the question that must be included in the answer. \"\n            \"Step 2: Then provide a detailed answer strictly based on the context. \"\n            \"Prioritize code examples if present. \"\n            \"If the answer is not in the context, say you don't know.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5101), Performs well on num_samples (10.0000), Performs well on raw_scores ([np.float64(0.295), np.float64(0.37), np.float64(0.6200000000000001), np.float64(0.6050000000000001), np.float64(0.5700000000000001), np.float64(0.7328571428571429), np.float64(0.6599999999999999), np.float64(0.46785714285714286), np.float64(0.42999999999999994), np.float64(0.35)])\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4963)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # Advanced separators to honor markdown hierarchy\n        splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        return splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING EXAMPLE (Lightweight) ---\n        # Sort by length or metadata (optional placeholder logic)\n        # docs = sorted(docs, key=lambda d: len(d.page_content), reverse=True)\n        \n        contexts = [d.page_content for d in docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            context_block += f\"Source {i+1} ({os.path.basename(src)}):\\n{content}\\n\\n\"\n\n        # Generation\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Answer the question based strictly on the context provided. \"\n            \"If the context contains code examples, prioritize them in your answer. \"\n            \"Include as much relevant detail as possible while staying faithful. \"\n            \"If the answer is not in the context, say you don't know.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n### Program D2 (Score: 0.5093)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n\n        # Two-stage chunking with richer markdown header hierarchy preservation\n        # First split by top-level headers (larger chunks) to isolate sections\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 4,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Then chunk each section into smaller chunks with overlap and add \"header_path\" metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for section_doc in header_sections:\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            # Collect all consecutive header lines at the start for richer header path (supports nested headers)\n            for i, line in enumerate(lines):\n                stripped = line.strip()\n                if stripped.startswith(\"#\"):\n                    header_lines.append(stripped)\n                    content_start = i + 1\n                else:\n                    if header_lines:\n                        break\n            header_path = \" > \".join(header_lines)\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk smaller with header_path metadata for context-aware retrieval\n            chunks = small_splitter.create_documents(\n                [content_text],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            all_chunks.extend(chunks)\n\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING ---\n        # Rerank retrieved docs by boosting those with header_path containing \"Reference\" or \"API\"\n        # Also boost docs containing exact query keywords for relevance\n        def rerank_key(doc):\n            header_path = doc.metadata.get(\"header_path\", \"\").lower()\n            score = 0\n            if \"reference\" in header_path:\n                score += 2\n            if \"api\" in header_path:\n                score += 1.5\n            # Boost longer chunks moderately (up to 1 point)\n            score += min(len(doc.page_content) / 1200.0, 1.0)\n\n            # Boost if query keywords appear in doc content (weight 0.75 per unique keyword)\n            query_words = set(query_str.lower().split())\n            content_words = set(re.findall(r'\\w+', doc.page_content.lower()))\n            common_words = query_words.intersection(content_words)\n            score += 0.75 * len(common_words)\n\n            # Slight boost if chunk header_path contains \"Tutorial\" to diversify knowledge\n            if \"tutorial\" in header_path:\n                score += 0.5\n\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        limited_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in limited_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in limited_docs]\n\n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = limited_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify any mandatory terms, definitions, or key concepts related to the question in the context.\\n\"\n            \"Step 2: Based strictly on the context, provide a detailed answer. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"Include relevant detail while staying faithful. \"\n            \"If the answer is not found, say 'I don't know'.\"\n        )\n\n        # Add explicit temperature override for deterministic output\n        res = self.llm.invoke(prompt)\n\n        gc.collect()\n\n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4720, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # Add \"header_path\" metadata to preserve markdown hierarchy context\n        # We do a first pass split by headers, then chunk each section smaller.\n        # This helps the LLM understand the chunk's location in the doc.\n\n        # Split by top level headers to get sections with header paths\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 4,  # Larger chunk to isolate header sections\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_docs = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Now chunk each header section into smaller chunks with overlap\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for hd in header_docs:\n            # Extract the header path from the start of hd.page_content lines\n            lines = hd.page_content.splitlines()\n            header_path = \"\"\n            content_start_idx = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_path = line.strip()\n                    content_start_idx = i + 1\n                    break\n            content = \"\\n\".join(lines[content_start_idx:])\n            if not content.strip():\n                # If no content after header, fallback to whole content\n                content = hd.page_content\n\n            chunks = small_splitter.create_documents(\n                [content],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            all_chunks.extend(chunks)\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING EXAMPLE (Lightweight) ---\n        # Boost chunks with \"Reference\" or \"Tutorial\" in source metadata\n        def rerank_key(doc):\n            src = doc.metadata.get(\"source\", \"\").lower()\n            score = 0\n            if \"reference\" in src:\n                score += 2\n            if \"tutorial\" in src:\n                score += 1\n            # Prefer longer chunks moderately\n            score += min(len(doc.page_content) / 1000, 1)\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation prompt to reduce noise\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        # Generation with chain-of-thought style instruction and mandatory term check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Before answering, analyze the context carefully for any mandatory terms or definitions related to the question. \"\n            \"Then provide a detailed answer strictly based on this context. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"If the answer is not found in the context, respond with 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], Object-oriented approach\n\n### Inspiration 2 (Score: 0.4437, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # Add \"header_path\" metadata to preserve markdown hierarchy context\n        # We do a first pass split by headers, then chunk each section smaller.\n        # This helps the LLM understand the chunk's location in the doc.\n\n        # Split by top level headers to get sections with header paths\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 4,  # Larger chunk to isolate header sections\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_docs = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Now chunk each header section into smaller chunks with overlap\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for hd in header_docs:\n            # Extract the header path from the start of hd.page_content lines\n            lines = hd.page_content.splitlines()\n            header_path = \"\"\n            content_start_idx = 0\n            # Collect header hierarchy path, not just first header line\n            header_lines = []\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                    content_start_idx = i + 1\n                # Stop after first non-header line to avoid mixing content\n                if not line.strip().startswith(\"#\") and header_lines:\n                    break\n            if header_lines:\n                header_path = \" > \".join(header_lines)\n            content = \"\\n\".join(lines[content_start_idx:])\n            if not content.strip():\n                # If no content after header, fallback to whole content\n                content = hd.page_content\n\n            chunks = small_splitter.create_documents(\n                [content],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            all_chunks.extend(chunks)\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING EXAMPLE (Lightweight) ---\n        # Boost chunks with \"Reference\" or \"Tutorial\" in source metadata and presence of query keywords\n        def rerank_key(doc):\n            src = doc.metadata.get(\"source\", \"\").lower()\n            score = 0\n            if \"reference\" in src:\n                score += 2.5\n            if \"tutorial\" in src:\n                score += 1.5\n            # Prefer longer chunks moderately\n            score += min(len(doc.page_content) / 1000, 1)\n            # Boost if query keywords appear in chunk (case-insensitive)\n            query_words = query_str.lower().split()\n            content_lower = doc.page_content.lower()\n            for qw in query_words:\n                if qw in content_lower:\n                    score += 0.3\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation prompt to reduce noise\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        # Generation with chain-of-thought style instruction and mandatory term check\n        # Add context compression: summarize contexts before asking final question to reduce prompt length\n        compress_prompt = (\n            f\"Summarize the following context in a concise way focusing on information relevant to the question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Summary:\"\n        )\n        summary_resp = self.llm.invoke(compress_prompt)\n        summary = summary_resp.content.strip()\n        \n        # Build final prompt with chain-of-thought and summary context\n        final_prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Summary of context:\\n{summary}\\n\\n\"\n            \"Step 1: Identify any mandatory terms, definitions, or key concepts related to the question.\\n\"\n            \"Step 2: Provide a detailed and precise answer strictly based on the summary. \"\n            \"If code examples are present, prioritize them. \"\n            \"If the answer is not found, say 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(final_prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.4663, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        \n        # Add \"header_path\" metadata to preserve markdown hierarchy context\n        # We do a first pass split by headers, then chunk each section smaller.\n        # This helps the LLM understand the chunk's location in the doc.\n\n        # Split by top level headers to get sections with header paths\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 4,  # Larger chunk to isolate header sections\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_docs = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Now chunk each header section into smaller chunks with overlap\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for hd in header_docs:\n            # Extract the header path from the start of hd.page_content lines\n            lines = hd.page_content.splitlines()\n            header_path = \"\"\n            content_start_idx = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_path = line.strip()\n                    content_start_idx = i + 1\n                    break\n            content = \"\\n\".join(lines[content_start_idx:])\n            if not content.strip():\n                # If no content after header, fallback to whole content\n                content = hd.page_content\n\n            chunks = small_splitter.create_documents(\n                [content],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            all_chunks.extend(chunks)\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING ENHANCED ---\n        # Boost chunks with \"Reference\" or \"Tutorial\" in source metadata\n        # Also boost docs whose header_path contains keywords like \"Reference\", \"API\", or \"Tutorial\"\n        # Also boost docs containing code blocks (```), and those with query keyword matches in content and header_path\n        import re\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n\n        def rerank_key(doc):\n            src = doc.metadata.get(\"source\", \"\").lower()\n            header_path = doc.metadata.get(\"header_path\", \"\").lower()\n            content = doc.page_content.lower()\n            score = 0\n            # Source boosts\n            if \"reference\" in src:\n                score += 2\n            if \"tutorial\" in src:\n                score += 1\n            # Header path boosts\n            if \"reference\" in header_path:\n                score += 2.5\n            if \"api\" in header_path:\n                score += 1.5\n            if \"tutorial\" in header_path:\n                score += 1\n            # Code block boost\n            if \"```\" in content:\n                score += 1\n            # Length boost capped at 1.0\n            score += min(len(doc.page_content) / 1000, 1)\n\n            # Boost for query word presence in header_path and content\n            header_path_words = set(re.findall(r'\\w+', header_path))\n            content_words = set(re.findall(r'\\w+', content))\n            common_header = query_words.intersection(header_path_words)\n            common_content = query_words.intersection(content_words)\n            score += 1.0 * len(common_header) + 0.5 * len(common_content)\n\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation prompt to reduce noise\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n        \n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        # Generation with chain-of-thought style instruction and mandatory term check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Before answering, analyze the context carefully for any mandatory terms or definitions related to the question. \"\n            \"Then provide a detailed answer strictly based on this context. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"If the answer is not found in the context, respond with 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], Object-oriented approach\n\n# Current Program\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import re\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract all header lines at start of section for richer header_path\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                else:\n                    if header_lines:\n                        content_start = i\n                        break\n            header_path = \" > \".join(header_lines) if header_lines else \"\"\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n\n        # --- AD-HOC RERANKING: prioritize docs containing query keywords in header_path ---\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n        def score_doc(d):\n            score = 0\n            # Boost if any query word in header_path metadata\n            header_path = d.metadata.get(\"header_path\", \"\").lower()\n            for word in query_words:\n                if word in header_path:\n                    score += 2\n            # Also boost docs with code blocks (``` present)\n            if '```' in d.page_content:\n                score += 1\n            # Boost longer docs (up to +1)\n            score += min(len(d.page_content) / 1000, 1)\n            # Additional boost for matching query words in content (weighted 0.5 per match)\n            content_lower = d.page_content.lower()\n            content_words = set(re.findall(r'\\w+', content_lower))\n            common = query_words.intersection(content_words)\n            score += 0.5 * len(common)\n            return score\n\n        docs = sorted(docs, key=score_doc, reverse=True)\n\n        # Limit contexts to rerank_top_n for generation precision\n        top_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in top_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in top_docs]\n\n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_info = top_docs[i].metadata.get(\"header_path\", \"\")\n            header_suffix = f\" [{header_info}]\" if header_info else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_suffix}:\\n{content}\\n\\n\"\n\n        # Generation prompt with chain-of-thought hint and mandatory terms check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify and list key terms from the question that must be included in the answer. \"\n            \"Step 2: Then provide a detailed answer strictly based on the context. \"\n            \"Prioritize code examples if present. \"\n            \"If the answer is not in the context, say you don't know.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, combined_score\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n        # --- AD-HOC RERANKING: prioritize docs containing query keywords in header_path ---\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n        def score_doc(d):\n            score = 0\n            # Boost if any query word in header_path metadata\n            header_path = d.metadata.get(\"header_path\", \"\").lower()\n            for word in query_words:\n                if word in header_path:\n                    score += 2\n            # Also boost docs with code blocks (``` present)\n            if '```' in d.page_content:\n                score += 1\n            # Boost longer docs (up to +1)\n            score += min(len(d.page_content) / 1000, 1)\n            # Additional boost for matching query words in content (weighted 0.5 per match)\n            content_lower = d.page_content.lower()\n            content_words = set(re.findall(r'\\w+', content_lower))\n            common = query_words.intersection(content_words)\n            score += 0.5 * len(common)\n            return score\n\n        docs = sorted(docs, key=score_doc, reverse=True)\n=======\n        # --- AD-HOC RERANKING: prioritize docs containing query keywords in header_path and code blocks ---\n        query_lower = query_str.lower()\n        query_words = set(query_lower.split())\n        def score_doc(d):\n            score = 0\n            # Boost if any query word in header_path metadata with higher weight\n            header_path = d.metadata.get(\"header_path\", \"\").lower()\n            for word in query_words:\n                if word in header_path:\n                    score += 2.5\n            # Boost docs with code blocks (``` present) more strongly\n            if '```' in d.page_content:\n                score += 1.5\n            # Boost longer docs (up to +1.2)\n            score += min(len(d.page_content) / 800, 1.2)\n            # Additional boost for matching unique query words in content (weighted 0.6 per match)\n            content_lower = d.page_content.lower()\n            content_words = set(re.findall(r'\\w+', content_lower))\n            common = query_words.intersection(content_words)\n            score += 0.6 * len(common)\n            # Small penalty for overly short docs to avoid less informative chunks\n            if len(d.page_content) < 200:\n                score -= 0.5\n            return score\n\n        docs = sorted(docs, key=score_doc, reverse=True)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # Generation prompt with chain-of-thought hint and mandatory terms check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify and list key terms from the question that must be included in the answer. \"\n            \"Step 2: Then provide a detailed answer strictly based on the context. \"\n            \"Prioritize code examples if present. \"\n            \"If the answer is not in the context, say you don't know.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n=======\n        # Generation prompt with chain-of-thought hint and mandatory terms check\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify and list key terms or definitions from the question that must be included in the answer. \"\n            \"Step 2: Then provide a detailed answer strictly based on the context. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"Include relevant detail while staying faithful to the context. \"\n            \"If the answer is not found in the context, respond with 'I don't know'.\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        \n        # Cleanup\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": contexts}\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import re\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract all header lines at start of section for richer header_path\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                else:\n                    if header_lines:\n                        content_start = i\n                        break\n            header_path = \" > \".join(header_lines) if header_lines else \"\"\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n=======\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import re\n        \n        # 2-stage chunking with header path metadata for context-aware splitting\n        # First, split by top-level markdown headers (to isolate sections)\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 3,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n        \n        # Then chunk each section into smaller chunks with overlap and add header_path metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        all_chunks = []\n        for section_doc in header_sections:\n            # Extract all consecutive header lines at start of section for richer header_path\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            for i, line in enumerate(lines):\n                if line.strip().startswith(\"#\"):\n                    header_lines.append(line.strip())\n                else:\n                    if header_lines:\n                        content_start = i\n                        break\n            header_path = \" > \".join(header_lines) if header_lines else \"\"\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk the content smaller with header_path metadata\n            chunks = small_splitter.create_documents([content_text], metadatas=[{\"source\": source, \"header_path\": header_path}])\n            all_chunks.extend(chunks)\n        \n        return all_chunks\n>>>>>>> REPLACE\n\n# Explanation\n\n1. **Chunking:** Added support for 5th level markdown headers in the header splitter separators to better capture deep sectioning in documentation, improving context granularity and retrieval precision.\n\n2. **Reranking:** Increased boost weights for chunks whose header_path contains query words and for chunks containing code blocks, as code is often critical in developer docs. Added a small penalty for very short chunks to avoid noise from trivial or empty chunks. Also adjusted length boost to be slightly higher and scale with chunk size.\n\n3. **Prompt:** Slightly refined the chain-of-thought prompt wording to emphasize inclusion of relevant detail and faithfulness, improving answer quality.\n\nThese targeted improvements maintain the existing architecture and complexity, add useful context hierarchy granularity, and improve the relevance signal in reranking, all expected to improve fitness score without increasing code length significantly."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}