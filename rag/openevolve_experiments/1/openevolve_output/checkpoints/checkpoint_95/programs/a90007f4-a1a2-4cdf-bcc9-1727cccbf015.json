{"id": "a90007f4-a1a2-4cdf-bcc9-1727cccbf015", "code": "import os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 1200 # Increased for better context\n        self.chunk_overlap = 250\n        self.top_k_vector = 15 # High k for retrieval phase\n        self.top_k_bm25 = 10\n        self.weight_vector = 0.6 # Preference for semantic\n        self.weight_bm25 = 0.4\n        self.rerank_top_n = 5 # Strict reranking for generation\n        self.temperature = 0.1\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")\n        \n        # Ingestion\n        documents = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                # Efficiently skip hidden directories (in-place)\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        documents.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not documents:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(documents, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(documents)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n\n        # Generation Config\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        \n        # Immediate cleanup of temporary ingestion objects\n        gc.collect()\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        # Lazy import for safety\n        from langchain_text_splitters import RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n\n        # Two-stage chunking with richer markdown header hierarchy preservation\n        # First split by top-level headers (larger chunks) to isolate sections\n        header_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size * 4,\n            chunk_overlap=0,\n            separators=[\"\\n# \", \"\\n## \", \"\\n### \", \"\\n#### \"]\n        )\n        header_sections = header_splitter.create_documents([text], metadatas=[{\"source\": source}])\n\n        # Then chunk each section into smaller chunks with overlap and add \"header_path\" metadata\n        small_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n\n        all_chunks = []\n        for section_doc in header_sections:\n            lines = section_doc.page_content.splitlines()\n            header_lines = []\n            content_start = 0\n            # Collect all consecutive header lines at the start for richer header path (supports nested headers)\n            for i, line in enumerate(lines):\n                stripped = line.strip()\n                if stripped.startswith(\"#\"):\n                    header_lines.append(stripped)\n                    content_start = i + 1\n                else:\n                    if header_lines:\n                        break\n            header_path = \" > \".join(header_lines)\n            content_text = \"\\n\".join(lines[content_start:]) if content_start < len(lines) else section_doc.page_content\n\n            # Chunk smaller with header_path metadata for context-aware retrieval\n            chunks = small_splitter.create_documents(\n                [content_text],\n                metadatas=[{\"source\": source, \"header_path\": header_path}]\n            )\n            all_chunks.extend(chunks)\n\n            # Also include the parent large chunk (the whole section_doc) as a bigger context chunk\n            # with the same header_path for small-to-big retrieval benefit\n            from langchain_core.documents import Document\n            parent_doc = Document(page_content=section_doc.page_content, metadata={\"source\": source, \"header_path\": header_path})\n            all_chunks.append(parent_doc)\n\n        return all_chunks\n\n    def _expand_query_logic(self, query: str) -> str:\n        if not self.expand_query:\n            return query\n        \n        prompt = f\"Provide 2-3 different ways to ask the following question to improve search recall:\\nQuestion: {query}\\nOutput ONLY the expanded queries, one per line.\"\n        res = self.llm.invoke(prompt)\n        expansions = res.content.split('\\n')\n        return query + \" \" + \" \".join(expansions[:2])\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # Retrieval\n        search_query = self._expand_query_logic(query_str)\n        docs = self.retriever.invoke(search_query)\n        \n        # --- AD-HOC RERANKING ---\n        # Rerank retrieved docs by boosting those with header_path containing \"Reference\" or \"API\"\n        # Also boost docs containing exact query keywords for relevance\n        def rerank_key(doc):\n            header_path = doc.metadata.get(\"header_path\", \"\").lower()\n            score = 0\n            if \"reference\" in header_path:\n                score += 2\n            if \"api\" in header_path:\n                score += 1.5\n            # Boost longer chunks moderately (up to 1 point)\n            score += min(len(doc.page_content) / 1200.0, 1.0)\n\n            # Boost if query keywords appear in doc content (weight 0.75 per unique keyword)\n            query_words = set(query_str.lower().split())\n            content_words = set(re.findall(r'\\w+', doc.page_content.lower()))\n            common_words = query_words.intersection(content_words)\n            score += 0.75 * len(common_words)\n\n            # Slight boost if chunk header_path contains \"Tutorial\" to diversify knowledge\n            if \"tutorial\" in header_path:\n                score += 0.5\n\n            # Penalty to reduce redundancy: penalize if chunk content is very similar to already selected chunks\n            # This is a lightweight heuristic to diversify context\n            # Use simple substring check of first 50 chars\n            limited_contexts = [d.page_content for d in docs[:self.rerank_top_n]]\n            snippet = doc.page_content[:50]\n            if any(snippet in c for c in limited_contexts if c != doc.page_content):\n                score -= 1.0\n\n            return score\n\n        docs = sorted(docs, key=rerank_key, reverse=True)\n\n        limited_docs = docs[:self.rerank_top_n]\n\n        contexts = [d.page_content for d in limited_docs]\n        sources = [d.metadata.get(\"source\", \"unknown\") for d in limited_docs]\n\n        context_block = \"\"\n        for i, (content, src) in enumerate(zip(contexts, sources)):\n            header_path = limited_docs[i].metadata.get(\"header_path\", \"\")\n            header_info = f\" [{header_path}]\" if header_path else \"\"\n            context_block += f\"Source {i+1} ({os.path.basename(src)}){header_info}:\\n{content}\\n\\n\"\n\n        prompt = (\n            f\"Question: {query_str}\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            \"Step 1: Identify any mandatory terms, definitions, or key concepts related to the question in the context.\\n\"\n            \"Step 2: Based strictly on the context, provide a detailed answer. \"\n            \"If code examples are present, prioritize them in your explanation. \"\n            \"Include relevant detail while staying faithful. \"\n            \"If the answer is not found, say 'I don't know'.\"\n        )\n\n        # Add explicit temperature override for deterministic output\n        res = self.llm.invoke(prompt)\n\n        gc.collect()\n\n        return {\"answer\": res.content, \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "b2a771b9-f046-4077-818f-284d20a8dfe6", "generation": 4, "timestamp": 1769537370.7837605, "iteration_found": 0, "metrics": {"combined_score": 0.5686190476190477, "num_samples": 10, "raw_scores": [0.28, 0.74, 0.595, 0.64, 0.5700000000000001, 0.5714285714285715, 0.51, 0.5764285714285715, 0.6383333333333333, 0.565]}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 32 lines with 38 lines\nChange 2: Replace 54 lines with 62 lines\nChange 3: Replace 16 lines with 16 lines", "parent_metrics": {"combined_score": 0.5093214285714286, "num_samples": 10, "raw_scores": [0.275, 0.555, 0.5700000000000001, 0.6000000000000001, 0.6889285714285714, 0.645, 0.33000000000000007, 0.42928571428571427, 0.46499999999999997, 0.535]}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}