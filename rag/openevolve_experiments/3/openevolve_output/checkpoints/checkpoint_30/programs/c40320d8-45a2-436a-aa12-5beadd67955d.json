{"id": "c40320d8-45a2-436a-aa12-5beadd67955d", "code": "import os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb, re.I) or re.search(r'\\b(a2a|auth)\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'\\bworkflow\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Add language tag to child chunks for better filtering\n                child_lang_match = re.search(r'```(\\w+)', c.page_content)\n                child_language = child_lang_match.group(1).lower() if child_lang_match else language\n                c.page_content = f\"{prefix} [LANG={child_language.upper()}] {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = child_language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            filtered_candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtering too strict, fallback to original set to maintain recall\n            if len(filtered_candidates) >= 4:\n                candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting with XML style and language filtering\n        final_contexts = []\n        seen_parents = set()\n        context_blocks = []\n        \n        def chunk_language_filter(chunk_text: str) -> bool:\n            if requested_lang is None:\n                return True\n            lang_tag = requested_lang.capitalize()\n            # Check for language tags in chunk content\n            if f\"[LANG={lang_tag.upper()}]\" in chunk_text:\n                return True\n            # Accept code chunks without explicit language tag to avoid losing relevant info\n            if chunk_text.startswith(\"[DOC_CODE]\"):\n                return True\n            return False\n        \n        for c in top_chunks:\n            if not chunk_language_filter(c.page_content):\n                continue\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Also filter parent by language\n                if not chunk_language_filter(parent.page_content):\n                    continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_blocks.append(f\"<source file='{src}' section='{breadcrumb}'>\\n{parent.page_content}\\n</source>\")\n        \n        context_block = \"\\n\\n\".join(context_blocks)\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a Google ADK technical expert assistant. Answer the user's question strictly using the provided context.\\n\"\n            \"Rules:\\n\"\n            \"1. If the answer is not contained within the context, respond exactly: 'I don't know from the provided documentation'.\\n\"\n            \"2. Always mention API classes or methods using the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' approach: first quote the relevant passage or code, then provide your explanation.\\n\"\n            \"4. Only provide code snippets or examples in the user-requested programming language (Python, Go, Java). If no language is requested, default to Python but acknowledge other languages exist in the docs.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "da8eaf23-9a8e-4957-ab1f-6f54851e5e2f", "generation": 2, "timestamp": 1769720639.670038, "iteration_found": 14, "metrics": {"combined_score": 0.47264285714285714, "num_samples": 10}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 7 lines with 7 lines\nChange 2: Replace 53 lines with 56 lines\nChange 3: Replace 40 lines with 52 lines\nChange 4: Replace 58 lines with 70 lines", "parent_metrics": {"combined_score": 0.539452380952381, "num_samples": 10}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert RAG system optimizer for Google ADK documentation. Improve the code to maximize RAG-pipeline performance.\n\nThe current architecture uses a **Parent-Child Retrieval** system with **Hybrid Search** and **LLM Reranking**.\n\n### High-Leverage Evolution Points:\n\n1. **Hyperparameter Synergy**: Optimize the balance between `chunk_size` (for retrieval precision), `top_k_vector/bm25` (for recall), and `weight_vector/bm25`. The documentation has many exact API names which may favor BM25, while conceptual \"how-to\" queries favor Vector.\n2. **Reranker Prompt Engineering**: The `_llm_rerank` prompt is critical. Evolve it to better identify relevance, handle multi-language snippets, or detect if a chunk contains a complete API definition vs. a partial snippet.\n3. **Metadata-Rich Ingestion**: Enhance `_chunk_document` to include more context in `breadcrumb` and `tagging`. Consider adding language-specific tags or project-area identifiers (e.g. `[A2A]`, `[WORKFLOW]`) to help the reranker and generator.\n4. **Context Assembly & Prompting**: Optimize the `context_block` formatting in `query`. Experiment with summarizing parent context or using XML-style tags to separate sources. Refine the final generation prompt for better \"Quote then Explain\" adherence.\n5. **Cross-Language Filtering**: Implement logic to detect the user's requested language and prioritize or filter retrieved chunks to reduce cross-language noise.\n\n**STRICT RULES**:\n- **Fork-Safety**: Avoid any top-level imports of `langchain`, `agno`, or `openai`. Use lazy imports inside methods.\n- **Compatibility**: Ensure `evaluate_rag(docs_path, query)` maintains its signature.\n- **Cleanup**: Always call `gc.collect()` after LLM calls or retrieval to maintain memory stability.\n\n**Example Improvement (Reranker Logic)**:\n```python\n# You can evolve the reranker prompt to be more specific:\nprompt = (\n    \"Role: ADK Expert Reranker. \"\n    \"Goal: Select chunks that provide EXECUTABLE code for the query. \"\n    f\"Query: {query}\\n\"\n    \"Chunks: ... \"\n)\n```\n- Maintain `evaluate_rag(docs_path, query)` signature and return keys: `answer`, `contexts`.\n- Keep `RAGSystem` class structure and lazy-loading in `__init__`.\n", "user": "# Current Program Information\n- Fitness: 0.5395\n- Feature coordinates: combined_score=0.54\n- Focus areas: - Fitness unchanged at 0.5395\n- Exploring combined_score=0.54 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### raw_scores\n```\n[0.08541666666666667, 0.47500000000000003, 0.5814285714285715, 0.6464285714285715, 0.5950000000000001, 0.6000000000000001, 0.7000000000000001, 0.68125, 0.45499999999999996, 0.5750000000000001]\n```\n\n### error_details\n```\n[{'sample': 3, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> # Core abstractions: wrap a function as a tool.\\n> from google.adk.tools import FunctionTool, ToolContext\\n> \\n> def get_time(tool_context: ToolContext) -> dict:\\n>     return {\"time\": \"12:00\"}\\n> \\n> time_tool = FunctionTool(func=get_time, name=\"get_time\")\\n>'}, {'sample': 4, 'type': 'code_error', 'message': '[\"Instantiation Error on line 28: name \\'MODEL_NAME\\' is not defined\", \"Instantiation Error on line 46: name \\'agent\\' is not defined\"]', 'bad_code': '# Copyright 2025 Google LLC\\n#\\n# Licensed under the Apache License, Version 2.0 (the \"License\");\\n# you may not use this file except in compliance with the License.\\n# You may obtain a copy of the License at\\n#\\n#     http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to in writing, software\\n# distributed under the License is distributed on an \"AS IS\" BASIS,\\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n# See the License for the specific language governing permissions and\\n# limitations under the License.\\n\\nimport asyncio\\n\\nfrom google.adk.agents import LlmAgent\\nfrom google.adk.runners import Runner\\nfrom google.adk.sessions import InMemorySessionService\\nfrom google.genai import types\\n\\nAPP_NAME = \"simple_qa_app\"\\nUSER_ID = \"user_123\"\\nSESSION_ID = \"session_qa_001\"\\nMODEL_NAME = \"gemini-2.0-flash\"\\n\\n# Define the LlmAgent that answers questions\\nagent = LlmAgent(\\n    name=\"simple_qa_agent\",\\n    model=MODEL_NAME,\\n    instruction=(\\n        \"You are a helpful assistant. Answer the user\\'s questions clearly and concisely.\"\\n    ),\\n    description=\"A simple question-answering agent.\",\\n)\\n\\n# Create session service and session\\nsession_service = InMemorySessionService()\\n# Create session asynchronously\\nasync def create_session():\\n    return await session_service.create_session(\\n        app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID\\n    )\\n\\n# Create runner\\nrunner = Runner(agent=agent, app_name=APP_NAME, session_service=session_service)\\n\\n# Function to call the agent asynchronously with a query and print the final response\\nasync def call_agent_async(query: str):\\n    content = types.Content(role=\"user\", parts=[types.Part(text=query)])\\n    print(f\"\\\\n--- Query: {query} ---\")\\n    final_response_text = \"No final response received.\"\\n\\n    try:\\n        async for event in runner.run_async(\\n            user_id=USER_ID, session_id=SESSION_ID, new_message=content\\n        ):\\n            # Check for final response event with text content\\n            if event.is_final_response() and event.content and event.content.parts:\\n                text = event.content.parts[0].text\\n                if text:\\n                    final_response_text = text.strip()\\n        print(f\"Agent Response: {final_response_text}\")\\n    except Exception as e:\\n        print(f\"Error during agent run: {e}\")\\n\\n# Main async function to run the example\\nasync def main():\\n    await create_session()\\n    await call_agent_async(\"What is the capital of France?\")\\n    await call_agent_async(\"Who wrote \\'Pride and Prejudice\\'?\")\\n\\n# Run the main async function\\nif __name__ == \"__main__\":\\n    asyncio.run(main())'}, {'sample': 5, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> > async for event in self.some_sub_agent.run_async(ctx):\\n> >     # Optionally inspect or log the event\\n> >     yield event  # Pass the event up\\n> >\\n\\n> > # Read data set by a previous agent\\n> > previous_result = ctx.session.state.get(\"some_key\")\\n> > \\n> > # Make a decision based on state\\n> > if previous_result == \"some_value\":\\n> >     # ... call a specific sub-agent ...\\n> > else:\\n> >     # ... call another sub-agent ...\\n> > \\n> > # Store a result for a later step (often done via a sub-agent\\'s output_key)\\n> > # ctx.session.state[\"my_custom_result\"] = \"calculated_value\"\\n> >\\n\\nimport logging\\nfrom typing import AsyncGenerator\\nfrom typing_extensions import override\\n\\nfrom google.adk.agents import BaseAgent\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom google.adk.events import Event\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass RoutingAgent(BaseAgent):\\n    \"\"\"\\n    A custom agent that routes execution to different sub-agents\\n    based on a value stored in the session state.\\n    \"\"\"\\n\\n    # Assume these sub-agents are passed during initialization and assigned as instance attributes\\n    sub_agent_a: BaseAgent\\n    sub_agent_b: BaseAgent\\n\\n    def __init__(self, name: str, sub_agent_a: BaseAgent, sub_agent_b: BaseAgent):\\n        super().__init__(name=name, sub_agents=[sub_agent_a, sub_agent_b])\\n        self.sub_agent_a = sub_agent_a\\n        self.sub_agent_b = sub_agent_b\\n\\n    @override\\n    async def _run_async_impl(\\n        self, ctx: InvocationContext\\n    ) -> AsyncGenerator[Event, None]:\\n        \"\"\"\\n        Routes to sub_agent_a or sub_agent_b based on the value of \\'route_key\\' in session state.\\n        \"\"\"\\n        logger.info(f\"[{self.name}] Starting routing logic.\")\\n\\n        route_value = ctx.session.state.get(\"route_key\")\\n        logger.info(f\"[{self.name}] route_key in session state: {route_value}\")\\n\\n        if route_value == \"use_a\":\\n            logger.info(f\"[{self.name}] Routing to sub_agent_a.\")\\n            async for event in self.sub_agent_a.run_async(ctx):\\n                yield event\\n        elif route_value == \"use_b\":\\n            logger.info(f\"[{self.name}] Routing to sub_agent_b.\")\\n            async for event in self.sub_agent_b.run_async(ctx):\\n                yield event\\n        else:\\n            logger.warning(f\"[{self.name}] route_key not set or unrecognized. Defaulting to sub_agent_a.\")\\n            async for event in self.sub_agent_a.run_async(ctx):\\n                yield event\\n\\n        logger.info(f\"[{self.name}] Routing logic completed.\")'}, {'sample': 6, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> from google.adk.tools import ToolContext, FunctionTool\\n> \\n> def update_user_preference(preference: str, value: str, tool_context: ToolContext):\\n>     \"\"\"Updates a user-specific preference.\"\"\"\\n>     user_prefs_key = \"user:preferences\"\\n>     # Get current preferences or initialize if none exist\\n>     preferences = tool_context.state.get(user_prefs_key, {})\\n>     preferences[preference] = value\\n>     # Write the updated dictionary back to the state\\n>     tool_context.state[user_prefs_key] = preferences\\n>     print(f\"Tool: Updated user preference \\'{preference}\\' to \\'{value}\\'\")\\n>     return {\"status\": \"success\", \"updated_preference\": preference}\\n> \\n> pref_tool = FunctionTool(func=update_user_preference)\\n> \\n> # In an Agent:\\n> # my_agent = Agent(..., tools=[pref_tool])\\n> \\n> # When the LLM calls update_user_preference(preference=\\'theme\\', value=\\'dark\\', ...):\\n> # The tool_context.state will be updated, and the change will be part of the\\n> # resulting tool response event\\'s actions.state_delta.\\n>'}, {'sample': 7, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 84)', 'bad_code': '# Python example of SequentialAgent pipeline with three LlmAgents passing data via output_key\\n\\nimport asyncio\\nfrom google.adk.agents import LlmAgent, SequentialAgent\\nfrom google.adk.runners import Runner\\nfrom google.adk.sessions import InMemorySessionService\\nfrom google.genai import types\\n\\n# --- Define the three LlmAgents ---\\n\\n# Agent 1: Generates initial data\\nagent1 = LlmAgent(\\n    name=\"Agent1_Generator\",\\n    instruction=\"Generate a greeting message.\",\\n    output_key=\"greeting\",\\n)\\n\\n# Agent 2: Processes the greeting from Agent1\\nagent2 = LlmAgent(\\n    name=\"Agent2_Processor\",\\n    instruction=\"Take the greeting: {greeting} and add a question: \\'How are you today?\\'\",\\n    output_key=\"processed_greeting\",\\n)\\n\\n# Agent 3: Finalizes the message based on processed_greeting\\nagent3 = LlmAgent(\\n    name=\"Agent3_Finalizer\",\\n    instruction=\"Based on the processed greeting: {processed_greeting}, respond with a friendly closing.\",\\n    output_key=\"final_message\",\\n)\\n\\n# --- Create the SequentialAgent pipeline ---\\npipeline_agent = SequentialAgent(\\n    name=\"GreetingPipeline\",\\n    sub_agents=[agent1, agent2, agent3],\\n)\\n\\n# --- Setup session and runner ---\\nAPP_NAME = \"GreetingApp\"\\nUSER_ID = \"user_001\"\\nSESSION_ID = \"session_001\"\\n\\nasync def main():\\n    # Create in-memory session service and session with empty initial state\\n    session_service = InMemorySessionService()\\n    session = await session_service.create_session(\\n        app_name=APP_NAME,\\n        user_id=USER_ID,\\n        session_id=SESSION_ID,\\n        state={}\\n    )\\n\\n    # Create the runner with the pipeline agent\\n    runner = Runner(\\n        agent=pipeline_agent,\\n        app_name=APP_NAME,\\n        session_service=session_service,\\n    )\\n\\n    # Create user input content (can be empty or a prompt)\\n    user_message = types.Content(role=\"user\", parts=[types.Part(text=\"Start the greeting pipeline.\")])\\n\\n    # Run the pipeline asynchronously\\n    events = runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=user_message)\\n\\n    final_response = None\\n    async for event in events:\\n        if event.is_final_response() and event.content and event.content.parts:\\n            final_response = event.content.parts[0].text\\n\\n    # Print the final output from the last agent\\n    print(\"Final Agent Output:\")\\n    print(final_response)\\n\\n    # Optionally, print the final session state to see all outputs\\n    final_session = await session_service.get_session(APP_NAME, USER_ID, SESSION_ID)\\n    print(\"\\\\nFinal Session State:\")\\n    import json\\n    print(json.dumps(final_session.state, indent=2))\\n\\n# Run the async main function\\nasyncio.run(main())\\n\\n> SequentialAgent(\\n>     name=\"GreetingPipeline\",\\n>     sub_agents=[agent1, agent2, agent3],\\n> )\\n>'}, {'sample': 8, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> from google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\n> from google.adk.events import Event, EventActions\\n> from google.adk.agents.invocation_context import InvocationContext\\n> from typing import AsyncGenerator\\n> \\n> class CheckCondition(BaseAgent): # Custom agent to check state\\n>     async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n>         status = ctx.session.state.get(\"status\", \"pending\")\\n>         is_done = (status == \"completed\")\\n>         yield Event(author=self.name, actions=EventActions(escalate=is_done)) # Escalate if done\\n> \\n> process_step = LlmAgent(name=\"ProcessingStep\") # Agent that might update state[\\'status\\']\\n> \\n> poller = LoopAgent(\\n>     name=\"StatusPoller\",\\n>     max_iterations=10,\\n>     sub_agents=[process_step, CheckCondition(name=\"Checker\")]\\n> )\\n> # When poller runs, it executes process_step then Checker repeatedly\\n> # until Checker escalates (state[\\'status\\'] == \\'completed\\') or 10 iterations pass.\\n>'}]\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 9 lines with 15 lines\nChange 2: Replace 34 lines with 40 lines\nChange 3: Replace 37 lines with 53 lines\nChange 4: Replace 38 lines with 58 lines\n- Metrics: combined_score: 0.5395, num_samples: 10.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Unknown changes\n- Metrics: combined_score: 0.5461, num_samples: 10.0000\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Change 1: Replace 9 lines with 9 lines\nChange 2: Replace 40 lines with 52 lines\nChange 3: Replace 70 lines with 13 lines\nChange 4: Replace 10 lines with 12 lines\n- Metrics: combined_score: 0.5520, num_samples: 10.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5520)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtered too strictly, fallback to original set\n            if len(candidates) < 3:\n                candidates = self.retriever.invoke(query_str)\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent.page_content}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5520), Performs well on num_samples (10.0000)\n\n### Program 2 (Score: 0.5461)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            content = d.page_content[:1500]\n            packed.append(f\"[{i}] {content}\")\n        \n        prompt = (\n            \"You are a reranker for Google ADK documentation. \"\n            \"Given a user query and a list of chunks, score each chunk from 0 to 100 based on its relevance. \"\n            \"Prioritize chunks that contain exact API names or code examples for the requested task. \"\n            f\"Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON: {'scores': {chunk_id: score, ...}}\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_block += f\"--- SOURCE: {src} | SECTION: {breadcrumb} ---\\n{parent.page_content}\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5461), Performs well on num_samples (10.0000)\n\n### Program 3 (Score: 0.5395)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags and breadcrumb in reranking context for better relevance detection\n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            content = d.page_content[:1400]\n            packed.append(f\"[{i}] Metadata: {meta}\\nContent: {content}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk 0-100 on relevance to the query.\\n\"\n            \"Prioritize:\\n\"\n            \"- chunks containing exact API names matching the query,\\n\"\n            \"- chunks with executable code snippets,\\n\"\n            \"- chunks containing complete API definitions rather than partial fragments.\\n\"\n            \"- consider multi-language code snippets and mark those matching the user's requested language.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtered too strictly, fallback to original set\n            if len(candidates) < 3:\n                candidates = self.retriever.invoke(query_str)\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent.page_content}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5395), Performs well on num_samples (10.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4947)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if found in breadcrumb or source filename\n            tags = []\n            if re.search(r'\\bA2A\\b', breadcrumb, re.I) or 'a2a' in source.lower():\n                tags.append(\"[A2A]\")\n            if re.search(r'\\bWORKFLOW\\b', breadcrumb, re.I) or 'workflow' in source.lower():\n                tags.append(\"[WORKFLOW]\")\n            if tags:\n                p.metadata[\"tags\"] = \" \".join(tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation and language tags if present\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                \n                # Add language tag from breadcrumb if detected\n                lang_tag = \"\"\n                lang_matches = re.findall(r'#### (\\w+) Implementation', c.page_content)\n                if lang_matches:\n                    lang_tag = f\"[{lang_matches[0].upper()}]\"\n                \n                # Add tags from parent metadata\n                tag_str = p.metadata.get(\"tags\", \"\")\n                \n                c.page_content = f\"{prefix} {lang_tag} {tag_str} {breadcrumb}\\n{c.page_content}\".strip()\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with improved prompt for multi-language and completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            # Indicate if chunk likely contains a full API def or partial snippet heuristically\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'class\\s+\\w+|func\\s+\\w+|def\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            packed.append(f\"[{i}] {completeness_tag} {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Task: Given a user query and a list of documentation chunks, assign a relevance score (0-100) to each chunk.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            f\"Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Output JSON with format: {'scores': {chunk_id: score, ...}}\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting with XML-style tags and language filtering\n        final_contexts = []\n        seen_parents = set()\n        context_blocks = []\n        \n        # Detect requested language from query (case-insensitive)\n        requested_lang = None\n        lang_candidates = ['python', 'go', 'java']\n        query_lower = query_str.lower()\n        for lang in lang_candidates:\n            if re.search(r'\\b' + lang + r'\\b', query_lower):\n                requested_lang = lang\n                break\n        \n        def chunk_language_filter(chunk_text: str) -> bool:\n            # Simple heuristic: check for language tags or code fences\n            if requested_lang is None:\n                return True\n            lang_tag = requested_lang.capitalize()\n            if f\"#### {lang_tag} Implementation\" in chunk_text:\n                return True\n            # Also accept if chunk mentions requested language in prefix or breadcrumb\n            if re.search(r'\\[' + requested_lang.upper() + r'\\]', chunk_text, re.I):\n                return True\n            # If chunk is code and no explicit language, accept by default\n            if chunk_text.startswith(\"[DOC_CODE]\"):\n                return True\n            return False\n        \n        for c in top_chunks:\n            if not chunk_language_filter(c.page_content):\n                continue\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent by language as well\n                if not chunk_language_filter(parent.page_content):\n                    continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_blocks.append(f\"<source file='{src}' section='{breadcrumb}'>\\n{parent.page_content}\\n</source>\")\n        \n        context_block = \"\\n\\n\".join(context_blocks)\n        \n        # 4. Generation (Strict Grounding) with improved prompt encouraging Quote then Explain and language adherence\n        prompt = (\n            \"You are a Google ADK technical expert assistant. Answer the user's question strictly using the provided context.\\n\"\n            \"Rules:\\n\"\n            \"1. If the answer is not contained within the context, respond exactly: 'I don't know from the provided documentation'.\\n\"\n            \"2. Always mention API classes or methods using the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' approach: first quote the relevant passage or code, then provide your explanation.\\n\"\n            \"4. Only provide code snippets or examples in the user-requested programming language (Python, Go, Java). If no language is requested, default to Python but acknowledge other languages exist in the docs.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n### Program D2 (Score: 0.5237)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags to help reranker identify language and completeness\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                # Try detect language from breadcrumb or content heuristics\n                if re.search(r'```python', d.page_content, re.I):\n                    lang_tag = \"[LANG=Python]\"\n                elif re.search(r'```go', d.page_content, re.I):\n                    lang_tag = \"[LANG=Go]\"\n                elif re.search(r'```java', d.page_content, re.I):\n                    lang_tag = \"[LANG=Java]\"\n            completeness_tag = \"[COMPLETE]\" if re.search(r'^\\s*(class|func|interface|def|type)\\s', d.page_content, re.I|re.M) else \"[PARTIAL]\"\n            \n            content_snippet = d.page_content[:1300].replace('\\n', ' ')\n            packed.append(f\"[{i}] {lang_tag} {completeness_tag} {content_snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 on relevance to the query, prioritizing:\\n\"\n            \"1) Exact API names or full definitions over partial snippets.\\n\"\n            \"2) Code examples executable in the requested language.\\n\"\n            \"3) Language requested by user query (detect language tags).\\n\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON ONLY with format: {'scores': {chunk_id: score, ...}}\\n\"\n            \"Scores must be integers 0 to 100.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5520, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtered too strictly, fallback to original set\n            if len(candidates) < 3:\n                candidates = self.retriever.invoke(query_str)\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent.page_content}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.4947, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if found in breadcrumb or source filename\n            tags = []\n            if re.search(r'\\bA2A\\b', breadcrumb, re.I) or 'a2a' in source.lower():\n                tags.append(\"[A2A]\")\n            if re.search(r'\\bWORKFLOW\\b', breadcrumb, re.I) or 'workflow' in source.lower():\n                tags.append(\"[WORKFLOW]\")\n            if tags:\n                p.metadata[\"tags\"] = \" \".join(tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation and language tags if present\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                \n                # Add language tag from breadcrumb if detected\n                lang_tag = \"\"\n                lang_matches = re.findall(r'#### (\\w+) Implementation', c.page_content)\n                if lang_matches:\n                    lang_tag = f\"[{lang_matches[0].upper()}]\"\n                \n                # Add tags from parent metadata\n                tag_str = p.metadata.get(\"tags\", \"\")\n                \n                c.page_content = f\"{prefix} {lang_tag} {tag_str} {breadcrumb}\\n{c.page_content}\".strip()\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with improved prompt for multi-language and completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            # Indicate if chunk likely contains a full API def or partial snippet heuristically\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'class\\s+\\w+|func\\s+\\w+|def\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            packed.append(f\"[{i}] {completeness_tag} {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Task: Given a user query and a list of documentation chunks, assign a relevance score (0-100) to each chunk.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            f\"Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Output JSON with format: {'scores': {chunk_id: score, ...}}\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting with XML-style tags and language filtering\n        final_contexts = []\n        seen_parents = set()\n        context_blocks = []\n        \n        # Detect requested language from query (case-insensitive)\n        requested_lang = None\n        lang_candidates = ['python', 'go', 'java']\n        query_lower = query_str.lower()\n        for lang in lang_candidates:\n            if re.search(r'\\b' + lang + r'\\b', query_lower):\n                requested_lang = lang\n                break\n        \n        def chunk_language_filter(chunk_text: str) -> bool:\n            # Simple heuristic: check for language tags or code fences\n            if requested_lang is None:\n                return True\n            lang_tag = requested_lang.capitalize()\n            if f\"#### {lang_tag} Implementation\" in chunk_text:\n                return True\n            # Also accept if chunk mentions requested language in prefix or breadcrumb\n            if re.search(r'\\[' + requested_lang.upper() + r'\\]', chunk_text, re.I):\n                return True\n            # If chunk is code and no explicit language, accept by default\n            if chunk_text.startswith(\"[DOC_CODE]\"):\n                return True\n            return False\n        \n        for c in top_chunks:\n            if not chunk_language_filter(c.page_content):\n                continue\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent by language as well\n                if not chunk_language_filter(parent.page_content):\n                    continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_blocks.append(f\"<source file='{src}' section='{breadcrumb}'>\\n{parent.page_content}\\n</source>\")\n        \n        context_block = \"\\n\\n\".join(context_blocks)\n        \n        # 4. Generation (Strict Grounding) with improved prompt encouraging Quote then Explain and language adherence\n        prompt = (\n            \"You are a Google ADK technical expert assistant. Answer the user's question strictly using the provided context.\\n\"\n            \"Rules:\\n\"\n            \"1. If the answer is not contained within the context, respond exactly: 'I don't know from the provided documentation'.\\n\"\n            \"2. Always mention API classes or methods using the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' approach: first quote the relevant passage or code, then provide your explanation.\\n\"\n            \"4. Only provide code snippets or examples in the user-requested programming language (Python, Go, Java). If no language is requested, default to Python but acknowledge other languages exist in the docs.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.5461, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            content = d.page_content[:1500]\n            packed.append(f\"[{i}] {content}\")\n        \n        prompt = (\n            \"You are a reranker for Google ADK documentation. \"\n            \"Given a user query and a list of chunks, score each chunk from 0 to 100 based on its relevance. \"\n            \"Prioritize chunks that contain exact API names or code examples for the requested task. \"\n            f\"Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON: {'scores': {chunk_id: score, ...}}\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_block += f\"--- SOURCE: {src} | SECTION: {breadcrumb} ---\\n{parent.page_content}\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n# Current Program\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags and breadcrumb in reranking context for better relevance detection\n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            content = d.page_content[:1400]\n            packed.append(f\"[{i}] Metadata: {meta}\\nContent: {content}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk 0-100 on relevance to the query.\\n\"\n            \"Prioritize:\\n\"\n            \"- chunks containing exact API names matching the query,\\n\"\n            \"- chunks with executable code snippets,\\n\"\n            \"- chunks containing complete API definitions rather than partial fragments.\\n\"\n            \"- consider multi-language code snippets and mark those matching the user's requested language.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtered too strictly, fallback to original set\n            if len(candidates) < 3:\n                candidates = self.retriever.invoke(query_str)\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent.page_content}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, combined_score\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n=======\n        self.top_k_vector = 25  # Slightly increase vector top_k for better recall on conceptual queries\n        self.top_k_bm25 = 30    # Increase BM25 top_k to boost recall on exact API term matches\n        self.weight_vector = 0.4  # Slightly favor BM25 as API names are important in docs\n        self.weight_bm25 = 0.6\n        self.rerank_top_n = 10  # More candidates for reranking to improve precision\n        self.temperature = 0.0\n        self.expand_query = False \n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n=======\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb, re.I) or re.search(r'\\b(a2a|auth)\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'\\bworkflow\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Add language tag to child chunks for better filtering\n                child_lang_match = re.search(r'```(\\w+)', c.page_content)\n                child_language = child_lang_match.group(1).lower() if child_lang_match else language\n                c.page_content = f\"{prefix} [LANG={child_language.upper()}] {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = child_language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags and breadcrumb in reranking context for better relevance detection\n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            content = d.page_content[:1400]\n            packed.append(f\"[{i}] Metadata: {meta}\\nContent: {content}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk 0-100 on relevance to the query.\\n\"\n            \"Prioritize:\\n\"\n            \"- chunks containing exact API names matching the query,\\n\"\n            \"- chunks with executable code snippets,\\n\"\n            \"- chunks containing complete API definitions rather than partial fragments.\\n\"\n            \"- consider multi-language code snippets and mark those matching the user's requested language.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n=======\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtered too strictly, fallback to original set\n            if len(candidates) < 3:\n                candidates = self.retriever.invoke(query_str)\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent.page_content}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n=======\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        if requested_lang:\n            filtered_candidates = [c for c in candidates if c.metadata.get(\"language\", \"\") == requested_lang]\n            # If filtering too strict, fallback to original set to maintain recall\n            if len(filtered_candidates) >= 4:\n                candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting with XML style and language filtering\n        final_contexts = []\n        seen_parents = set()\n        context_blocks = []\n        \n        def chunk_language_filter(chunk_text: str) -> bool:\n            if requested_lang is None:\n                return True\n            lang_tag = requested_lang.capitalize()\n            # Check for language tags in chunk content\n            if f\"[LANG={lang_tag.upper()}]\" in chunk_text:\n                return True\n            # Accept code chunks without explicit language tag to avoid losing relevant info\n            if chunk_text.startswith(\"[DOC_CODE]\"):\n                return True\n            return False\n        \n        for c in top_chunks:\n            if not chunk_language_filter(c.page_content):\n                continue\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Also filter parent by language\n                if not chunk_language_filter(parent.page_content):\n                    continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_blocks.append(f\"<source file='{src}' section='{breadcrumb}'>\\n{parent.page_content}\\n</source>\")\n        \n        context_block = \"\\n\\n\".join(context_blocks)\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a Google ADK technical expert assistant. Answer the user's question strictly using the provided context.\\n\"\n            \"Rules:\\n\"\n            \"1. If the answer is not contained within the context, respond exactly: 'I don't know from the provided documentation'.\\n\"\n            \"2. Always mention API classes or methods using the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' approach: first quote the relevant passage or code, then provide your explanation.\\n\"\n            \"4. Only provide code snippets or examples in the user-requested programming language (Python, Go, Java). If no language is requested, default to Python but acknowledge other languages exist in the docs.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n>>>>>>> REPLACE"]}}, "artifacts_json": "{\"raw_scores\": [0.33999999999999997, 0.5700000000000001, 0.62, 0.5, 0.5, 0.5, 0.5, 0.6464285714285715, 0.5, 0.05000000000000002], \"error_details\": [{\"sample\": 4, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 1: No module named 'google.ai'\\\", \\\"Import Error on line 2: No module named 'google.ai'\\\", \\\"Import Error on line 7: No module named 'google.ai'\\\"]\", \"bad_code\": \"from google.ai.generativelanguage import TextServiceClient\\nfrom google.ai.generativelanguage_v1beta2.types import (\\n    Model,\\n    TextPrompt,\\n    GenerateTextRequest,\\n)\\nfrom google.ai.generativelanguage_v1beta2 import LlmAgent\\n\\ndef run_llm_agent():\\n    # Initialize the TextServiceClient\\n    client = TextServiceClient()\\n\\n    # Define the model to use\\n    model = Model(name=\\\"models/text-bison-001\\\")\\n\\n    # Create a prompt for the agent\\n    prompt = TextPrompt(text=\\\"What is the capital of France?\\\")\\n\\n    # Create a GenerateTextRequest\\n    request = GenerateTextRequest(\\n        model=model,\\n        prompt=prompt,\\n        max_tokens=100,\\n    )\\n\\n    # Initialize the LlmAgent with the client\\n    agent = LlmAgent(client=client)\\n\\n    # Run the agent to get the response\\n    response = agent.generate_text(request=request)\\n\\n    # Print the response text\\n    print(response.candidates[0].output)\\n\\nif __name__ == \\\"__main__\\\":\\n    run_llm_agent()\"}, {\"sample\": 5, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 1: No module named 'google.actions'\\\"]\", \"bad_code\": \"from google.actions.sdk.v2.conversation import CustomAgent, SessionState, AgentResponse\\n\\nclass RoutingCustomAgent(CustomAgent):\\n    def __init__(self, sub_agents):\\n        # sub_agents is a dict mapping keys to sub-agent instances\\n        self.sub_agents = sub_agents\\n\\n    def handle(self, session_state: SessionState, user_input: str) -> AgentResponse:\\n        # Extract routing key from session state\\n        routing_key = session_state.parameters.get(\\\"route_key\\\")\\n        \\n        # Route to the appropriate sub-agent based on routing_key\\n        if routing_key in self.sub_agents:\\n            sub_agent = self.sub_agents[routing_key]\\n            return sub_agent.handle(session_state, user_input)\\n        else:\\n            # Default response if no matching sub-agent\\n            return AgentResponse(text=\\\"Sorry, I couldn't find the right agent to handle your request.\\\")\\n\\n# Example usage:\\n# sub_agents = {\\n#     \\\"sales\\\": SalesAgent(),\\n#     \\\"support\\\": SupportAgent(),\\n# }\\n# agent = RoutingCustomAgent(sub_agents)\"}, {\"sample\": 7, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 2: No module named 'google.adk.runner'\\\", \\\"Import Error on line 5: No module named 'rx'\\\"]\", \"bad_code\": \"from google.adk.agents import LlmAgent, SequentialAgent\\nfrom google.adk.runner import InMemoryRunner\\nfrom google.adk.sessions import Session\\nfrom google.genai.types import Content, Part\\nfrom rx import operators as ops\\n\\n# --- 1. Define Sub-Agents for Each Pipeline Stage ---\\n\\n# Validator Agent: validates input and outputs status\\nvalidator_agent = LlmAgent(\\n    name=\\\"ValidateInput\\\",\\n    instruction=\\\"Validate the input.\\\",\\n    output_key=\\\"validation_status\\\"  # Saves output to state['validation_status']\\n)\\n\\n# Processor Agent: processes data only if validation_status is 'valid'\\nprocessor_agent = LlmAgent(\\n    name=\\\"ProcessData\\\",\\n    instruction=\\\"Process data if {validation_status} is 'valid'.\\\",\\n    output_key=\\\"result\\\"  # Saves output to state['result']\\n)\\n\\n# Reporter Agent: reports the result from previous step\\nreporter_agent = LlmAgent(\\n    name=\\\"ReportResult\\\",\\n    instruction=\\\"Report the result from {result}.\\\"\\n    # No output_key needed if final output only\\n)\\n\\n# --- 2. Create the SequentialAgent pipeline ---\\ndata_pipeline = SequentialAgent(\\n    name=\\\"DataPipeline\\\",\\n    sub_agents=[validator_agent, processor_agent, reporter_agent]\\n)\\n\\n# --- 3. Run the pipeline with InMemoryRunner ---\\n\\ndef run_pipeline(user_id: str, prompt: str):\\n    runner = InMemoryRunner(data_pipeline, \\\"DataPipeline\\\")\\n    # Create a session for the user\\n    session = runner.sessionService().createSession(\\\"DataPipeline\\\", user_id).blockingGet()\\n    # Prepare user message content\\n    user_message = Content.fromParts(Part.fromText(prompt))\\n    # Run the agent asynchronously\\n    event_stream = runner.runAsync(user_id, session.id(), user_message)\\n    # Stream and print final response\\n    event_stream.pipe(\\n        ops.filter(lambda e: e.finalResponse())\\n    ).subscribe(lambda e: print(e.stringifyContent()))\\n\\n# Example usage\\nif __name__ == \\\"__main__\\\":\\n    run_pipeline(\\\"test_user_123\\\", \\\"Please validate and process this input data.\\\")\"}, {\"sample\": 9, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 1: No module named 'google.ai'\\\", \\\"Import Error on line 2: No module named 'google.ai'\\\", \\\"Import Error on line 3: No module named 'google.ai'\\\", \\\"Import Error on line 4: No module named 'google.ai'\\\", \\\"Import Error on line 5: No module named 'google.ai'\\\", \\\"Import Error on line 6: No module named 'google.ai'\\\", \\\"Import Error on line 7: No module named 'google.ai'\\\", \\\"Import Error on line 8: No module named 'google.ai'\\\", \\\"Import Error on line 9: No module named 'google.ai'\\\", \\\"Import Error on line 10: No module named 'google.ai'\\\", \\\"Import Error on line 11: No module named 'google.ai'\\\", \\\"Import Error on line 12: No module named 'google.ai'\\\", \\\"Import Error on line 13: No module named 'google.ai'\\\", \\\"Import Error on line 14: No module named 'google.ai'\\\", \\\"Import Error on line 15: No module named 'google.ai'\\\", \\\"Import Error on line 16: No module named 'google.ai'\\\", \\\"Import Error on line 17: No module named 'google.ai'\\\", \\\"Import Error on line 18: No module named 'google.ai'\\\", \\\"Import Error on line 19: No module named 'google.ai'\\\", \\\"Import Error on line 20: No module named 'google.ai'\\\", \\\"Import Error on line 21: No module named 'google.ai'\\\", \\\"Import Error on line 22: No module named 'google.ai'\\\", \\\"Import Error on line 23: No module named 'google.ai'\\\", \\\"Import Error on line 24: No module named 'google.ai'\\\", \\\"Import Error on line 25: No module named 'google.ai'\\\", \\\"Import Error on line 26: No module named 'google.ai'\\\", \\\"Import Error on line 27: No module named 'google.ai'\\\", \\\"Import Error on line 28: No module named 'google.ai'\\\", \\\"Import Error on line 29: No module named 'google.ai'\\\", \\\"Import Error on line 30: No module named 'google.ai'\\\", \\\"Import Error on line 31: No module named 'google.ai'\\\", \\\"Import Error on line 32: No module named 'google.ai'\\\", \\\"Import Error on line 33: No module named 'google.ai'\\\", \\\"Import Error on line 34: No module named 'google.ai'\\\", \\\"Import Error on line 35: No module named 'google.ai'\\\", \\\"Import Error on line 36: No module named 'google.ai'\\\", \\\"Import Error on line 37: No module named 'google.ai'\\\", \\\"Import Error on line 38: No module named 'google.ai'\\\", \\\"Import Error on line 39: No module named 'google.ai'\\\", \\\"Import Error on line 40: No module named 'google.ai'\\\", \\\"Import Error on line 41: No module named 'google.ai'\\\", \\\"Import Error on line 42: No module named 'google.ai'\\\", \\\"Import Error on line 43: No module named 'google.ai'\\\", \\\"Import Error on line 44: No module named 'google.ai'\\\", \\\"Import Error on line 45: No module named 'google.ai'\\\", \\\"Import Error on line 46: No module named 'google.ai'\\\", \\\"Import Error on line 47: No module named 'google.ai'\\\", \\\"Import Error on line 48: No module named 'google.ai'\\\", \\\"Import Error on line 49: No module named 'google.ai'\\\", \\\"Import Error on line 50: No module named 'google.ai'\\\", \\\"Import Error on line 51: No module named 'google.ai'\\\", \\\"Import Error on line 52: No module named 'google.ai'\\\", \\\"Import Error on line 53: No module named 'google.ai'\\\", \\\"Import Error on line 54: No module named 'google.ai'\\\", \\\"Import Error on line 55: No module named 'google.ai'\\\", \\\"Import Error on line 56: No module named 'google.ai'\\\", \\\"Import Error on line 57: No module named 'google.ai'\\\", \\\"Import Error on line 58: No module named 'google.ai'\\\", \\\"Import Error on line 59: No module named 'google.ai'\\\", \\\"Import Error on line 60: No module named 'google.ai'\\\", \\\"Import Error on line 61: No module named 'google.ai'\\\", \\\"Import Error on line 62: No module named 'google.ai'\\\", \\\"Import Error on line 63: No module named 'google.ai'\\\", \\\"Import Error on line 64: No module named 'google.ai'\\\", \\\"Import Error on line 65: No module named 'google.ai'\\\", \\\"Import Error on line 66: No module named 'google.ai'\\\", \\\"Import Error on line 67: No module named 'google.ai'\\\", \\\"Import Error on line 68: No module named 'google.ai'\\\", \\\"Import Error on line 69: No module named 'google.ai'\\\", \\\"Import Error on line 70: No module named 'google.ai'\\\", \\\"Import Error on line 71: No module named 'google.ai'\\\", \\\"Import Error on line 72: No module named 'google.ai'\\\", \\\"Import Error on line 73: No module named 'google.ai'\\\", \\\"Import Error on line 74: No module named 'google.ai'\\\", \\\"Import Error on line 75: No module named 'google.ai'\\\"]\", \"bad_code\": \"from google.ai.generativeai import TextGenerationClient\\nfrom google.ai.generativeai.types import GenerateTextRequest\\nfrom google.ai.generativeai.types import TextPrompt\\nfrom google.ai.generativeai.types import SafetySettings\\nfrom google.ai.generativeai.types import SafetySetting\\nfrom google.ai.generativeai.types import SafetyCategory\\nfrom google.ai.generativeai.types import SafetyRating\\nfrom google.ai.generativeai.types import SafetyFeedback\\nfrom google.ai.generativeai.types import SafetyFeedbackType\\nfrom google.ai.generativeai.types import SafetyFeedbackReason\\nfrom google.ai.generativeai.types import SafetyFeedbackComment\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadata\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntry\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueNull\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAny\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValue\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueString\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueInt\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueFloat\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueBool\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueList\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueMap\\nfrom google.ai.generativeai.types import SafetyFeedbackMetadataEntryValueAnyValueAnyValueAnyValueAnyValueAnyValueAnyValueNull\\n\\nclass CustomStoryAgent:\\n    def __init__(self):\\n        self.client = TextGenerationClient()\\n\\n    async def _run_async_impl(self, prompt: str) -> str:\\n        # Generate story\\n        generate_request = GenerateTextRequest(\\n            model=\\\"models/story-generator\\\",\\n            prompt=TextPrompt(text=prompt),\\n            safety_settings=[\\n                SafetySettings(\\n                    category=SafetyCategory.TOXICITY,\\n                    threshold=SafetyRating.HIGH\\n                )\\n            ],\\n        )\\n        response = await self.client.generate_text(request=generate_request)\\n        story = response.text\\n\\n        # Check tone by generating a tone analysis\\n        tone_prompt = f\\\"Analyze the tone of the following story and respond with 'Positive' or 'Negative':\\\\n{story}\\\"\\n        tone_request = GenerateTextRequest(\\n            model=\\\"models/tone-analyzer\\\",\\n            prompt=TextPrompt(text=tone_prompt),\\n        )\\n        tone_response = await self.client.generate_text(request=tone_request)\\n        tone = tone_response.text.strip().lower()\\n\\n        # Regenerate if tone is negative\\n        if \\\"negative\\\" in tone:\\n            regenerate_request = GenerateTextRequest(\\n                model=\\\"models/story-generator\\\",\\n                prompt=TextPrompt(text=prompt + \\\"\\\\nMake the tone positive.\\\"),\\n                safety_settings=[\\n                    SafetySettings(\\n                        category=SafetyCategory.TOXICITY,\\n                        threshold=SafetyRating.HIGH\\n                    )\\n                ],\\n            )\\n            regenerate_response = await self.client.generate_text(request=regenerate_request)\\n            story = regenerate_response.text\\n\\n        return story\"}]}", "artifact_dir": null, "embedding": null}