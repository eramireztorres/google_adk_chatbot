{"id": "d9d3de03-0944-4344-9f03-d66ff3036c4d", "code": "import os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Exact API names matching the query.\\n\"\n            \"- Complete API definitions over partial snippets.\\n\"\n            \"- Code examples in the user's requested programming language if specified.\\n\"\n            \"- Proper handling of multi-language snippets.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return a JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "6d67c591-ee07-4362-addd-bca584a4296b", "generation": 3, "timestamp": 1769724404.5212262, "iteration_found": 27, "metrics": {"combined_score": 0.5695178571428572, "num_samples": 10}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 9 lines with 10 lines\nChange 2: Replace 12 lines with 14 lines\nChange 3: Replace 18 lines with 25 lines\nChange 4: Replace 47 lines with 44 lines\nChange 5: Replace 23 lines with 25 lines\nChange 6: Replace 22 lines with 23 lines\nChange 7: Replace 19 lines with 20 lines", "parent_metrics": {"combined_score": 0.552904761904762, "num_samples": 10}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert RAG system optimizer for Google ADK documentation. Improve the code to maximize RAG-pipeline performance.\n\nThe current architecture uses a **Parent-Child Retrieval** system with **Hybrid Search** and **LLM Reranking**.\n\n### High-Leverage Evolution Points:\n\n1. **Hyperparameter Synergy**: Optimize the balance between `chunk_size` (for retrieval precision), `top_k_vector/bm25` (for recall), and `weight_vector/bm25`. The documentation has many exact API names which may favor BM25, while conceptual \"how-to\" queries favor Vector.\n2. **Reranker Prompt Engineering**: The `_llm_rerank` prompt is critical. Evolve it to better identify relevance, handle multi-language snippets, or detect if a chunk contains a complete API definition vs. a partial snippet.\n3. **Metadata-Rich Ingestion**: Enhance `_chunk_document` to include more context in `breadcrumb` and `tagging`. Consider adding language-specific tags or project-area identifiers (e.g. `[A2A]`, `[WORKFLOW]`) to help the reranker and generator.\n4. **Context Assembly & Prompting**: Optimize the `context_block` formatting in `query`. Experiment with summarizing parent context or using XML-style tags to separate sources. Refine the final generation prompt for better \"Quote then Explain\" adherence.\n5. **Cross-Language Filtering**: Implement logic to detect the user's requested language and prioritize or filter retrieved chunks to reduce cross-language noise.\n\n**STRICT RULES**:\n- **Fork-Safety**: Avoid any top-level imports of `langchain`, `agno`, or `openai`. Use lazy imports inside methods.\n- **Compatibility**: Ensure `evaluate_rag(docs_path, query)` maintains its signature.\n- **Cleanup**: Always call `gc.collect()` after LLM calls or retrieval to maintain memory stability.\n\n**Example Improvement (Reranker Logic)**:\n```python\n# You can evolve the reranker prompt to be more specific:\nprompt = (\n    \"Role: ADK Expert Reranker. \"\n    \"Goal: Select chunks that provide EXECUTABLE code for the query. \"\n    f\"Query: {query}\\n\"\n    \"Chunks: ... \"\n)\n```\n- Maintain `evaluate_rag(docs_path, query)` signature and return keys: `answer`, `contexts`.\n- Keep `RAGSystem` class structure and lazy-loading in `__init__`.\n", "user": "# Current Program Information\n- Fitness: 0.5529\n- Feature coordinates: combined_score=0.55\n- Focus areas: - Fitness unchanged at 0.5529\n- Exploring combined_score=0.55 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### raw_scores\n```\n[0.5, 0.4541666666666667, 0.5, 0.5892857142857143, 0.6050000000000001, 0.68, 0.5875, 0.6630952380952382, 0.525, 0.42500000000000004]\n```\n\n### error_details\n```\n[{'sample': 1, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': \"def run(new_query, ...):\\n    # 1. Append user query to session history\\n    session_service.append_event(session, Event(author='user', content=new_query))\\n\\n    # 2. Start agent event generation\\n    agent_event_generator = agent_to_run.run_async(context)\\n\\n    async for event in agent_event_generator:\\n        # 3. Process event and commit changes\\n        session_service.append_event(session, event)\\n\\n        # 4. Yield event upstream (e.g., to UI)\\n        yield event\\n        # 5. Agent resumes after yield, loop continues\"}, {'sample': 3, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> def get_weather(city: str) -> dict:\\n>     \"\"\"Retrieves weather for a city.\"\"\"\\n>     return {\"status\": \"success\", \"temperature\": \"25\u00b0C\"}\\n>\\n\\nfrom google.adk.tools import FunctionTool\\n\\ndef list_user_files_py(tool_context: ToolContext) -> str:\\n    \"\"\"Tool to list available artifacts for the user.\"\"\"\\n    # function implementation here\\n    ...\\n\\nlist_files_tool = FunctionTool(func=list_user_files_py)\\n\\nfrom google.adk.tools import FunctionTool\\n\\ndef get_weather(city: str) -> dict:\\n    \"\"\"Retrieves weather for a city.\"\"\"\\n    # Your logic here, e.g., call a weather API\\n    return {\"status\": \"success\", \"temperature\": \"25\u00b0C\"}\\n\\nweather_tool = FunctionTool(func=get_weather)'}, {'sample': 4, 'type': 'code_error', 'message': '[\"Instantiation Error on line 17: name \\'MODEL_NAME\\' is not defined\"]', 'bad_code': '# Complete Python example to run a simple LlmAgent that answers questions\\n\\nimport asyncio\\nfrom google.adk.agents import LlmAgent\\nfrom google.adk.runners import Runner\\nfrom google.adk.sessions import InMemorySessionService\\nfrom google.genai import types\\nfrom google.genai.types import Content, Part\\n\\n# --- Constants ---\\nAPP_NAME = \"simple_qa_app\"\\nUSER_ID = \"user1234\"\\nSESSION_ID = \"session_qa_001\"\\nMODEL_NAME = \"gemini-2.0-flash\"\\n\\n# --- Define the LlmAgent ---\\nqa_agent = LlmAgent(\\n    name=\"simple_qa_agent\",\\n    model=MODEL_NAME,\\n    instruction=(\\n        \"You are a helpful assistant. Answer the user\\'s questions clearly and concisely.\"\\n    ),\\n    description=\"A simple question-answering agent.\",\\n)\\n\\n# --- Setup session service and runner ---\\nsession_service = InMemorySessionService()\\n\\nasync def main():\\n    # Create a session for the user\\n    await session_service.create_session(\\n        app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID\\n    )\\n\\n    # Create a runner to run the agent\\n    runner = Runner(agent=qa_agent, app_name=APP_NAME, session_service=session_service)\\n\\n    # Prepare user query as Content\\n    user_query = \"What is the capital of France?\"\\n    content = Content(role=\"user\", parts=[Part(text=user_query)])\\n\\n    print(f\"\\\\n--- Sending query to agent: {user_query} ---\")\\n\\n    # Run the agent asynchronously and print the final response\\n    final_response = \"No response received.\"\\n    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):\\n        if event.is_final_response() and event.content and event.content.parts:\\n            final_response = event.content.parts[0].text.strip()\\n            print(f\"\\\\n\ud83d\udfe2 Agent final response:\\\\n{final_response}\")\\n\\nif __name__ == \"__main__\":\\n    asyncio.run(main())'}, {'sample': 5, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> async for event in self.some_sub_agent.run_async(ctx):\\n>     # Optionally inspect or log the event\\n>     yield event # Pass the event up\\n>\\n\\n> # Read data set by a previous agent\\n> previous_result = ctx.session.state.get(\"some_key\")\\n> \\n> # Make a decision based on state\\n> if previous_result == \"some_value\":\\n>     # ... call a specific sub-agent ...\\n> else:\\n>     # ... call another sub-agent ...\\n> \\n> # Store a result for a later step (often done via a sub-agent\\'s output_key)\\n> # ctx.session.state[\"my_custom_result\"] = \"calculated_value\"\\n>\\n\\nfrom typing import AsyncGenerator\\nfrom google.adk.agents import BaseAgent, LlmAgent\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom google.adk.events import Event\\n\\nclass RoutingAgent(BaseAgent):\\n    # Define sub-agents as instance attributes\\n    agent_a: LlmAgent\\n    agent_b: LlmAgent\\n\\n    model_config = {\"arbitrary_types_allowed\": True}\\n\\n    def __init__(self, name: str, agent_a: LlmAgent, agent_b: LlmAgent):\\n        sub_agents_list = [agent_a, agent_b]\\n        super().__init__(name=name, agent_a=agent_a, agent_b=agent_b, sub_agents=sub_agents_list)\\n\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        # Read routing key from session state\\n        route_key = ctx.session.state.get(\"route_key\")\\n\\n        if route_key == \"use_agent_a\":\\n            # Route to agent_a\\n            async for event in self.agent_a.run_async(ctx):\\n                yield event\\n        elif route_key == \"use_agent_b\":\\n            # Route to agent_b\\n            async for event in self.agent_b.run_async(ctx):\\n                yield event\\n        else:\\n            # Default or fallback behavior\\n            # For example, yield an event indicating no route matched\\n            from google.adk.events import Event\\n            yield Event(\\n                author=\"RoutingAgent\",\\n                content=None,\\n                metadata={\"message\": \"No valid route_key found in session state.\"}\\n            )'}, {'sample': 6, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> from google.adk.tools import ToolContext, FunctionTool\\n> \\n> def update_user_preference(preference: str, value: str, tool_context: ToolContext):\\n>     \"\"\"Updates a user-specific preference.\"\"\"\\n>     user_prefs_key = \"user:preferences\"\\n>     # Get current preferences or initialize if none exist\\n>     preferences = tool_context.state.get(user_prefs_key, {})\\n>     preferences[preference] = value\\n>     # Write the updated dictionary back to the state\\n>     tool_context.state[user_prefs_key] = preferences\\n>     print(f\"Tool: Updated user preference \\'{preference}\\' to \\'{value}\\'\")\\n>     return {\"status\": \"success\", \"updated_preference\": preference}\\n> \\n> pref_tool = FunctionTool(func=update_user_preference)\\n>\\n\\nfrom google.adk.tools import ToolContext, FunctionTool\\n\\ndef update_user_preference(preference: str, value: str, tool_context: ToolContext):\\n    user_prefs_key = \"user:preferences\"\\n    preferences = tool_context.state.get(user_prefs_key, {})\\n    preferences[preference] = value\\n    tool_context.state[user_prefs_key] = preferences\\n    print(f\"Tool: Updated user preference \\'{preference}\\' to \\'{value}\\'\")\\n    return {\"status\": \"success\", \"updated_preference\": preference}\\n\\npref_tool = FunctionTool(func=update_user_preference)'}, {'sample': 7, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 58)', 'bad_code': '# Python\\n\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\nfrom google.adk.runner import InMemoryRunner\\nfrom google.adk.sessions import Session\\nfrom google.genai.types import Content, Part\\nfrom google.adk.events import Event\\n\\n# --- 1. Define the three LlmAgents with output_key to pass data via shared state ---\\n\\n# First agent: validates input and outputs \\'validation_status\\'\\nvalidator = LlmAgent(\\n    name=\"ValidateInput\",\\n    instruction=\"Validate the input.\",\\n    output_key=\"validation_status\"\\n)\\n\\n# Second agent: processes data if validation_status is \\'valid\\', outputs \\'result\\'\\nprocessor = LlmAgent(\\n    name=\"ProcessData\",\\n    instruction=\"Process data if {validation_status} is \\'valid\\'.\",\\n    output_key=\"result\"\\n)\\n\\n# Third agent: reports the result, reads \\'result\\' from state\\nreporter = LlmAgent(\\n    name=\"ReportResult\",\\n    instruction=\"Report the result from {result}.\"\\n)\\n\\n# --- 2. Create the SequentialAgent pipeline with the three sub_agents ---\\ndata_pipeline = SequentialAgent(\\n    name=\"DataPipeline\",\\n    sub_agents=[validator, processor, reporter]\\n)\\n\\n# --- 3. Create an InMemoryRunner to run the pipeline ---\\nrunner = InMemoryRunner(data_pipeline, \"DataPipelineApp\")\\n\\n# --- 4. Create a session for a user ---\\nuser_id = \"user_123\"\\nsession = runner.session_service().create_session(\"DataPipelineApp\", user_id).blocking_get()\\n\\n# --- 5. Prepare user input as Content ---\\nuser_input_text = \"Please validate and process this input data.\"\\nuser_message = Content.from_parts(Part.from_text(user_input_text))\\n\\n# --- 6. Run the pipeline asynchronously and print final response ---\\nevent_stream = runner.run_async(user_id, session.id(), user_message)\\n\\ndef print_final_response(event: Event):\\n    if event.final_response():\\n        print(\"Final response from pipeline:\")\\n        print(event.stringify_content())\\n\\nevent_stream.blocking_for_each(print_final_response)\\n\\n> validator = LlmAgent(name=\"ValidateInput\", instruction=\"Validate the input.\", output_key=\"validation_status\")\\n> processor = LlmAgent(name=\"ProcessData\", instruction=\"Process data if {validation_status} is \\'valid\\'.\", output_key=\"result\")\\n> reporter = LlmAgent(name=\"ReportResult\", instruction=\"Report the result from {result}.\")\\n> data_pipeline = SequentialAgent(name=\"DataPipeline\", sub_agents=[validator, processor, reporter])\\n>'}, {'sample': 8, 'type': 'code_error', 'message': 'Syntax Error: invalid syntax (<unknown>, line 1)', 'bad_code': '> # Conceptual Example: Loop with Condition\\n> from google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\n> from google.adk.events import Event, EventActions\\n> from google.adk.agents.invocation_context import InvocationContext\\n> from typing import AsyncGenerator\\n> \\n> class CheckCondition(BaseAgent): # Custom agent to check state\\n>     async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n>         status = ctx.session.state.get(\"status\", \"pending\")\\n>         is_done = (status == \"completed\")\\n>         yield Event(author=self.name, actions=EventActions(escalate=is_done)) # Escalate if done\\n> \\n> process_step = LlmAgent(name=\"ProcessingStep\") # Agent that might update state[\\'status\\']\\n> \\n> poller = LoopAgent(\\n>     name=\"StatusPoller\",\\n>     max_iterations=10,\\n>     sub_agents=[process_step, CheckCondition(name=\"Checker\")]\\n> )\\n> # When poller runs, it executes process_step then Checker repeatedly\\n> # until Checker escalates (state[\\'status\\'] == \\'completed\\') or 10 iterations pass.\\n>\\n\\nfrom google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckCondition(BaseAgent):\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        status = ctx.session.state.get(\"status\", \"pending\")\\n        should_exit = (status == \"completed\")\\n        yield Event(author=self.name, actions=EventActions(escalate=should_exit))\\n\\n# Agent that performs some processing and updates state[\\'status\\']\\nprocess_agent = LlmAgent(name=\"ProcessAgent\", instruction=\"Do some work and update state[\\'status\\'].\")\\n\\nretry_loop = LoopAgent(\\n    name=\"RetryLoop\",\\n    max_iterations=5,\\n    sub_agents=[process_agent, CheckCondition(name=\"ExitChecker\")]\\n)'}, {'sample': 9, 'type': 'code_error', 'message': '[\"Instantiation Error on line 92: name \\'GEMINI_2_FLASH\\' is not defined\", \"Instantiation Error on line 100: name \\'GEMINI_2_FLASH\\' is not defined\", \"Instantiation Error on line 113: name \\'StoryToneAgent\\' is not defined\"]', 'bad_code': 'import logging\\nfrom typing import AsyncGenerator\\nfrom typing_extensions import override\\n\\nfrom google.adk.agents import LlmAgent, BaseAgent\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom google.adk.events import Event\\n\\nlogger = logging.getLogger(__name__)\\nlogging.basicConfig(level=logging.INFO)\\n\\nclass StoryToneAgent(BaseAgent):\\n    \"\"\"\\n    Custom agent for story generation with tone checking and conditional regeneration.\\n    \"\"\"\\n\\n    # Declare the agents as class attributes with type hints\\n    story_generator: LlmAgent\\n    tone_check: LlmAgent\\n\\n    model_config = {\"arbitrary_types_allowed\": True}\\n\\n    def __init__(\\n        self,\\n        name: str,\\n        story_generator: LlmAgent,\\n        tone_check: LlmAgent,\\n    ):\\n        \"\"\"\\n        Initializes the StoryToneAgent.\\n\\n        Args:\\n            name: The name of the agent.\\n            story_generator: An LlmAgent to generate the initial story.\\n            tone_check: An LlmAgent to analyze the tone.\\n        \"\"\"\\n        sub_agents_list = [story_generator, tone_check]\\n\\n        super().__init__(\\n            name=name,\\n            story_generator=story_generator,\\n            tone_check=tone_check,\\n            sub_agents=sub_agents_list,\\n        )\\n\\n    @override\\n    async def _run_async_impl(\\n        self, ctx: InvocationContext\\n    ) -> AsyncGenerator[Event, None]:\\n        \"\"\"\\n        Orchestrates the story generation, tone checking, and conditional regeneration.\\n        \"\"\"\\n        logger.info(f\"[{self.name}] Starting story generation workflow.\")\\n\\n        # 1. Generate the initial story\\n        logger.info(f\"[{self.name}] Running StoryGenerator...\")\\n        async for event in self.story_generator.run_async(ctx):\\n            logger.info(f\"[{self.name}] Event from StoryGenerator: {event.model_dump_json(indent=2, exclude_none=True)}\")\\n            yield event\\n\\n        # Check if story was generated\\n        if \"current_story\" not in ctx.session.state or not ctx.session.state[\"current_story\"]:\\n            logger.error(f\"[{self.name}] Failed to generate initial story. Aborting workflow.\")\\n            return  # Stop processing if no story\\n\\n        logger.info(f\"[{self.name}] Story state after generation: {ctx.session.state.get(\\'current_story\\')}\")\\n\\n        # 2. Run tone check\\n        logger.info(f\"[{self.name}] Running ToneCheck...\")\\n        async for event in self.tone_check.run_async(ctx):\\n            logger.info(f\"[{self.name}] Event from ToneCheck: {event.model_dump_json(indent=2, exclude_none=True)}\")\\n            yield event\\n\\n        tone_check_result = ctx.session.state.get(\"tone_check_result\")\\n        logger.info(f\"[{self.name}] Tone check result: {tone_check_result}\")\\n\\n        # 3. Conditional regeneration if tone is negative\\n        if tone_check_result == \"negative\":\\n            logger.info(f\"[{self.name}] Tone is negative. Regenerating story...\")\\n            async for event in self.story_generator.run_async(ctx):\\n                logger.info(f\"[{self.name}] Event from StoryGenerator (Regen): {event.model_dump_json(indent=2, exclude_none=True)}\")\\n                yield event\\n        else:\\n            logger.info(f\"[{self.name}] Tone is not negative. Keeping current story.\")\\n\\n        logger.info(f\"[{self.name}] Workflow finished.\")\\n\\n\\n# Example instantiation of the LlmAgents (replace model and instructions as needed)\\nGEMINI_2_FLASH = \"gemini-2.0-flash\"\\n\\nstory_generator = LlmAgent(\\n    name=\"StoryGenerator\",\\n    model=GEMINI_2_FLASH,\\n    instruction=\"You are a story writer. Write a short story (around 100 words) on the topic: {topic}\",\\n    input_schema=None,\\n    output_key=\"current_story\",\\n)\\n\\ntone_check = LlmAgent(\\n    name=\"ToneCheck\",\\n    model=GEMINI_2_FLASH,\\n    instruction=(\\n        \"You are a tone analyzer. Analyze the tone of the story provided: {current_story}. \"\\n        \"Output only one word: \\'positive\\' if the tone is generally positive, \"\\n        \"\\'negative\\' if the tone is generally negative, or \\'neutral\\' otherwise.\"\\n    ),\\n    input_schema=None,\\n    output_key=\"tone_check_result\",\\n)\\n\\n# Create the custom agent instance\\nstory_tone_agent = StoryToneAgent(\\n    name=\"StoryToneAgent\",\\n    story_generator=story_generator,\\n    tone_check=tone_check,\\n)'}]\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 9 lines with 9 lines\nChange 2: Replace 18 lines with 24 lines\nChange 3: Replace 47 lines with 50 lines\nChange 4: Replace 51 lines with 73 lines\n- Metrics: combined_score: 0.5529, num_samples: 10.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 13 lines with 14 lines\nChange 2: Replace 14 lines with 14 lines\nChange 3: Replace 6 lines with 19 lines\nChange 4: Replace 37 lines with 45 lines\nChange 5: Replace 16 lines with 20 lines\nChange 6: Replace 15 lines with 15 lines\nChange 7: Replace 11 lines with 11 lines\n- Metrics: combined_score: 0.5879, num_samples: 10.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 39 lines with 48 lines\nChange 2: Replace 37 lines with 53 lines\nChange 3: Replace 40 lines with 54 lines\nChange 4: Replace 65 lines with 67 lines\n- Metrics: combined_score: 0.5918, num_samples: 10.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5918)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    # Only ingest .md files, skip hidden and non-API docs\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n\n                        # Add language and project tags in chunk metadata by filename heuristics and content\n                        lang_tag = None\n                        # Detect language from filename and also from code fences in content for synergy\n                        if re.search(r'\\bpython\\b', file.lower()):\n                            lang_tag = \"[LANG_PYTHON]\"\n                        elif re.search(r'\\bgo\\b', file.lower()):\n                            lang_tag = \"[LANG_GO]\"\n                        elif re.search(r'\\bjava\\b', file.lower()):\n                            lang_tag = \"[LANG_JAVA]\"\n                        else:\n                            # Fallback: detect language from first code fence in text content\n                            code_lang_match = re.search(r'```(\\w+)', text_content)\n                            if code_lang_match:\n                                lang = code_lang_match.group(1).lower()\n                                if lang in (\"python\", \"go\", \"java\"):\n                                    lang_tag = f\"[LANG_{lang.upper()}]\"\n\n                        # Project area tags example: detect A2A, WORKFLOW from path or filename heuristics\n                        project_tag = None\n                        if \"a2a\" in root.lower() or \"a2a\" in file.lower():\n                            project_tag = \"[A2A]\"\n                        elif \"workflow\" in root.lower() or \"workflow\" in file.lower():\n                            project_tag = \"[WORKFLOW]\"\n\n                        chunks = self._chunk_document(text_content, file_path)\n                        # Inject tags into each chunk content for better reranking and generation\n                        for c in chunks:\n                            tags = []\n                            if lang_tag: tags.append(lang_tag)\n                            if project_tag: tags.append(project_tag)\n                            if tags:\n                                c.page_content = \" \".join(tags) + \" \" + c.page_content\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n\n            # Detect language tag from first code fence in parent content\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n\n            # Heuristic project-area tagging based on breadcrumb or source path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n\n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for code, language, and completeness.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1500].replace('\\n', ' ')  # flatten newlines for prompt\n            # Indicate if chunk looks like a full API def or partial snippet\n            is_complete_api = \"Complete API definition\" if re.search(r'^\\s*(class|func|interface|def|type)\\s', snippet, re.I|re.M) else \"Partial snippet\"\n            # Include language tag if present in metadata or content\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                lang_search = re.search(r'\\[LANG=([A-Za-z]+)\\]', d.page_content)\n                if lang_search:\n                    lang_tag = f\"[LANG={lang_search.group(1)}]\"\n                else:\n                    # Fallback heuristic by code fences\n                    if re.search(r'```python', d.page_content, re.I):\n                        lang_tag = \"[LANG=Python]\"\n                    elif re.search(r'```go', d.page_content, re.I):\n                        lang_tag = \"[LANG=Go]\"\n                    elif re.search(r'```java', d.page_content, re.I):\n                        lang_tag = \"[LANG=Java]\"\n            packed.append(f\"[{i}] {lang_tag} ({is_complete_api}) {snippet}\")\n        \n        prompt = (\n            \"Role: Google ADK Expert Reranker.\\n\"\n            \"Goal: Given the user query and a list of documentation chunks, assign a relevance score 0-100. \"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query,\\n\"\n            \"- Complete API definitions over partial snippets,\\n\"\n            \"- Relevant code examples,\\n\"\n            \"- Matching requested programming language if specified.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return a JSON object with format: {'scores': {chunk_id: score, ...}} with scores as integers.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Sort indices by score descending\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Detect requested language from query (if any)\n        requested_lang = None\n        lang_patterns = {\n            \"python\": r\"\\bpython\\b\",\n            \"go\": r\"\\bgo\\b\",\n            \"java\": r\"\\bjava\\b\",\n        }\n        for lang, pattern in lang_patterns.items():\n            if re.search(pattern, query_str, re.I):\n                requested_lang = lang.upper()\n                break\n\n        # 2. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 3. Filter candidates by language tag if requested to reduce noise\n        if requested_lang:\n            filtered = []\n            lang_tag = f\"[LANG_{requested_lang}]\"\n            for c in candidates:\n                if lang_tag in c.page_content:\n                    filtered.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered and len(filtered) >= max(3, self.rerank_top_n):\n                candidates = filtered\n\n        # 4. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 5. Parent Retrieval & Formatting with XML-style tags and summarized parents\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Summarize parent to first 1000 chars for conciseness\n                parent_summary = parent.page_content[:1000].strip() + (\"...\" if len(parent.page_content) > 1000 else \"\")\n                context_block += (\n                    f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent_summary}\\n</source>\\n\\n\"\n                )\n\n        # 6. Generation (Strict Grounding) with improved prompt to emphasize quote/explain and language\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using ONLY the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not found in the context, explicitly respond: 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc or code snippet, then provide your explanation.\\n\"\n            \"4. Only provide code or examples in the requested programming language if specified by the user. \"\n            \"If no language is specified, default to Python but mention that other languages exist.\\n\"\n            \"5. When quoting code, explicitly indicate the programming language of the snippet.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5918), Performs well on num_samples (10.0000)\n\n### Program 2 (Score: 0.5879)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks with enhanced flattening and language tag normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            # Normalize language tag: map common aliases and lowercase\n            lang_map = {\"py\": \"PYTHON\", \"python\": \"PYTHON\", \"go\": \"GO\", \"golang\": \"GO\", \"java\": \"JAVA\"}\n            lang_tag = lang_map.get(label.lower(), label.upper())\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n\n        # Remove tabs wrappers but keep tabs content flattened with language tags\n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            # Add project-area tags heuristically based on breadcrumb content for better reranking and generation\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            tags = []\n            if re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                tags.append(\"[WORKFLOW]\")\n            if re.search(r'\\ba2a\\b', breadcrumb, re.I) or re.search(r'a2a', source, re.I):\n                tags.append(\"[A2A]\")\n            if re.search(r'\\bapi\\b', breadcrumb, re.I):\n                tags.append(\"[API]\")\n            tag_str = \" \".join(tags) if tags else \"[GENERAL]\"\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            p.metadata[\"tags\"] = tag_str\n            self.parent_docs[parent_id] = p\n\n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Incorporate tags and language info into chunk content for reranker and better filtering\n                # Try detect language from markdown tabs or code fences for explicit tagging\n                lang_tag = \"\"\n                lang_search = re.search(r'\\[([A-Z]+)\\]\\s+\\w+\\s+Implementation', c.page_content)\n                if lang_search:\n                    lang_tag = f\"[LANG={lang_search.group(1)}]\"\n                else:\n                    # fallback: detect language from code fences in chunk\n                    fence_lang_search = re.search(r'```(\\w+)', c.page_content)\n                    if fence_lang_search:\n                        lang_tag = f\"[LANG={fence_lang_search.group(1).upper()}]\"\n                    else:\n                        lang_tag = \"[LANG=UNKNOWN]\"\n                c.page_content = f\"{prefix} {lang_tag} {tag_str} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"tags\"] = tag_str\n                c.metadata[\"language\"] = lang_tag.strip(\"[]\").replace(\"LANG=\", \"\").lower()\n                child_chunks.append(c)\n\n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n\n        packed = []\n        requested_lang = None\n        # Detect requested language from query for reranker prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            lang = d.metadata.get(\"language\", \"unknown\")\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the query.\\n\"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query\\n\"\n            \"- Complete API definitions over partial snippets\\n\"\n            \"- Code examples in the user's requested programming language\\n\"\n            \"- Proper handling of multi-language snippets\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n\n        # Determine requested language from query for filtering\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query_str, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag if language requested, with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for d in candidates:\n                tags = d.metadata.get(\"tags\", \"\")\n                lang = d.metadata.get(\"language\", \"\").lower()\n                # Match requested language tag in content or metadata tags or language field\n                if (f\"[{requested_lang.upper()}]\" in d.page_content or\n                    f\"[{requested_lang.upper()}]\" in tags or\n                    lang == requested_lang):\n                    filtered_candidates.append(d)\n            # Use filtered candidates only if sufficient count, else fallback to full set\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n\n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n\n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML-like tags for clearer source separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. Only provide code or explanations in the user's requested language if specified; otherwise, default to Python but mention that other languages are available.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n\n        res = self.llm.invoke(prompt)\n        gc.collect()\n\n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5879), Performs well on num_samples (10.0000)\n\n### Program 3 (Score: 0.5529)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags to help reranker identify language and completeness\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                # Try detect language from breadcrumb or content heuristics\n                if re.search(r'```python', d.page_content, re.I):\n                    lang_tag = \"[LANG=Python]\"\n                elif re.search(r'```go', d.page_content, re.I):\n                    lang_tag = \"[LANG=Go]\"\n                elif re.search(r'```java', d.page_content, re.I):\n                    lang_tag = \"[LANG=Java]\"\n            # Detect if chunk likely contains a complete API definition or partial snippet\n            completeness_tag = \"[COMPLETE]\" if re.search(\n                r'^\\s*(class|func|interface|def|type|package|func\\s+main)\\s', d.page_content, re.I|re.M) else \"[PARTIAL]\"\n            \n            content_snippet = d.page_content[:1300].replace('\\n', ' ')\n            packed.append(f\"[{i}] {lang_tag} {completeness_tag} {content_snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 on relevance to the query, prioritizing:\\n\"\n            \"1) Exact API names or full definitions over partial snippets.\\n\"\n            \"2) Code examples executable in the requested language.\\n\"\n            \"3) Language requested by user query (detect language tags).\\n\"\n            \"4) Prefer chunks with complete API definitions or full function/class blocks.\\n\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON ONLY with format: {'scores': {chunk_id: score, ...}}\\n\"\n            \"Scores must be integers 0 to 100.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5529), Performs well on num_samples (10.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5237)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags to help reranker identify language and completeness\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                # Try detect language from breadcrumb or content heuristics\n                if re.search(r'```python', d.page_content, re.I):\n                    lang_tag = \"[LANG=Python]\"\n                elif re.search(r'```go', d.page_content, re.I):\n                    lang_tag = \"[LANG=Go]\"\n                elif re.search(r'```java', d.page_content, re.I):\n                    lang_tag = \"[LANG=Java]\"\n            completeness_tag = \"[COMPLETE]\" if re.search(r'^\\s*(class|func|interface|def|type)\\s', d.page_content, re.I|re.M) else \"[PARTIAL]\"\n            \n            content_snippet = d.page_content[:1300].replace('\\n', ' ')\n            packed.append(f\"[{i}] {lang_tag} {completeness_tag} {content_snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 on relevance to the query, prioritizing:\\n\"\n            \"1) Exact API names or full definitions over partial snippets.\\n\"\n            \"2) Code examples executable in the requested language.\\n\"\n            \"3) Language requested by user query (detect language tags).\\n\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON ONLY with format: {'scores': {chunk_id: score, ...}}\\n\"\n            \"Scores must be integers 0 to 100.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n### Program D2 (Score: 0.5461)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            content = d.page_content[:1500]\n            packed.append(f\"[{i}] {content}\")\n        \n        prompt = (\n            \"You are a reranker for Google ADK documentation. \"\n            \"Given a user query and a list of chunks, score each chunk from 0 to 100 based on its relevance. \"\n            \"Prioritize chunks that contain exact API names or code examples for the requested task. \"\n            f\"Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON: {'scores': {chunk_id: score, ...}}\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_block += f\"--- SOURCE: {src} | SECTION: {breadcrumb} ---\\n{parent.page_content}\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5918, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    # Only ingest .md files, skip hidden and non-API docs\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n\n                        # Add language and project tags in chunk metadata by filename heuristics and content\n                        lang_tag = None\n                        # Detect language from filename and also from code fences in content for synergy\n                        if re.search(r'\\bpython\\b', file.lower()):\n                            lang_tag = \"[LANG_PYTHON]\"\n                        elif re.search(r'\\bgo\\b', file.lower()):\n                            lang_tag = \"[LANG_GO]\"\n                        elif re.search(r'\\bjava\\b', file.lower()):\n                            lang_tag = \"[LANG_JAVA]\"\n                        else:\n                            # Fallback: detect language from first code fence in text content\n                            code_lang_match = re.search(r'```(\\w+)', text_content)\n                            if code_lang_match:\n                                lang = code_lang_match.group(1).lower()\n                                if lang in (\"python\", \"go\", \"java\"):\n                                    lang_tag = f\"[LANG_{lang.upper()}]\"\n\n                        # Project area tags example: detect A2A, WORKFLOW from path or filename heuristics\n                        project_tag = None\n                        if \"a2a\" in root.lower() or \"a2a\" in file.lower():\n                            project_tag = \"[A2A]\"\n                        elif \"workflow\" in root.lower() or \"workflow\" in file.lower():\n                            project_tag = \"[WORKFLOW]\"\n\n                        chunks = self._chunk_document(text_content, file_path)\n                        # Inject tags into each chunk content for better reranking and generation\n                        for c in chunks:\n                            tags = []\n                            if lang_tag: tags.append(lang_tag)\n                            if project_tag: tags.append(project_tag)\n                            if tags:\n                                c.page_content = \" \".join(tags) + \" \" + c.page_content\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n\n            # Detect language tag from first code fence in parent content\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            p.metadata[\"language\"] = language\n\n            # Heuristic project-area tagging based on breadcrumb or source path\n            if re.search(r'a2a|auth', breadcrumb, re.I) or re.search(r'a2a|auth', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'workflow', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n\n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                c.page_content = f\"{prefix} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for code, language, and completeness.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1500].replace('\\n', ' ')  # flatten newlines for prompt\n            # Indicate if chunk looks like a full API def or partial snippet\n            is_complete_api = \"Complete API definition\" if re.search(r'^\\s*(class|func|interface|def|type)\\s', snippet, re.I|re.M) else \"Partial snippet\"\n            # Include language tag if present in metadata or content\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                lang_search = re.search(r'\\[LANG=([A-Za-z]+)\\]', d.page_content)\n                if lang_search:\n                    lang_tag = f\"[LANG={lang_search.group(1)}]\"\n                else:\n                    # Fallback heuristic by code fences\n                    if re.search(r'```python', d.page_content, re.I):\n                        lang_tag = \"[LANG=Python]\"\n                    elif re.search(r'```go', d.page_content, re.I):\n                        lang_tag = \"[LANG=Go]\"\n                    elif re.search(r'```java', d.page_content, re.I):\n                        lang_tag = \"[LANG=Java]\"\n            packed.append(f\"[{i}] {lang_tag} ({is_complete_api}) {snippet}\")\n        \n        prompt = (\n            \"Role: Google ADK Expert Reranker.\\n\"\n            \"Goal: Given the user query and a list of documentation chunks, assign a relevance score 0-100. \"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query,\\n\"\n            \"- Complete API definitions over partial snippets,\\n\"\n            \"- Relevant code examples,\\n\"\n            \"- Matching requested programming language if specified.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return a JSON object with format: {'scores': {chunk_id: score, ...}} with scores as integers.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Sort indices by score descending\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Detect requested language from query (if any)\n        requested_lang = None\n        lang_patterns = {\n            \"python\": r\"\\bpython\\b\",\n            \"go\": r\"\\bgo\\b\",\n            \"java\": r\"\\bjava\\b\",\n        }\n        for lang, pattern in lang_patterns.items():\n            if re.search(pattern, query_str, re.I):\n                requested_lang = lang.upper()\n                break\n\n        # 2. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 3. Filter candidates by language tag if requested to reduce noise\n        if requested_lang:\n            filtered = []\n            lang_tag = f\"[LANG_{requested_lang}]\"\n            for c in candidates:\n                if lang_tag in c.page_content:\n                    filtered.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered and len(filtered) >= max(3, self.rerank_top_n):\n                candidates = filtered\n\n        # 4. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 5. Parent Retrieval & Formatting with XML-style tags and summarized parents\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Summarize parent to first 1000 chars for conciseness\n                parent_summary = parent.page_content[:1000].strip() + (\"...\" if len(parent.page_content) > 1000 else \"\")\n                context_block += (\n                    f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent_summary}\\n</source>\\n\\n\"\n                )\n\n        # 6. Generation (Strict Grounding) with improved prompt to emphasize quote/explain and language\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using ONLY the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not found in the context, explicitly respond: 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc or code snippet, then provide your explanation.\\n\"\n            \"4. Only provide code or examples in the requested programming language if specified by the user. \"\n            \"If no language is specified, default to Python but mention that other languages exist.\\n\"\n            \"5. When quoting code, explicitly indicate the programming language of the snippet.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.5879, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks with enhanced flattening and language tag normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            # Normalize language tag: map common aliases and lowercase\n            lang_map = {\"py\": \"PYTHON\", \"python\": \"PYTHON\", \"go\": \"GO\", \"golang\": \"GO\", \"java\": \"JAVA\"}\n            lang_tag = lang_map.get(label.lower(), label.upper())\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n\n        # Remove tabs wrappers but keep tabs content flattened with language tags\n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            # Add project-area tags heuristically based on breadcrumb content for better reranking and generation\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            tags = []\n            if re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                tags.append(\"[WORKFLOW]\")\n            if re.search(r'\\ba2a\\b', breadcrumb, re.I) or re.search(r'a2a', source, re.I):\n                tags.append(\"[A2A]\")\n            if re.search(r'\\bapi\\b', breadcrumb, re.I):\n                tags.append(\"[API]\")\n            tag_str = \" \".join(tags) if tags else \"[GENERAL]\"\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            p.metadata[\"tags\"] = tag_str\n            self.parent_docs[parent_id] = p\n\n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Incorporate tags and language info into chunk content for reranker and better filtering\n                # Try detect language from markdown tabs or code fences for explicit tagging\n                lang_tag = \"\"\n                lang_search = re.search(r'\\[([A-Z]+)\\]\\s+\\w+\\s+Implementation', c.page_content)\n                if lang_search:\n                    lang_tag = f\"[LANG={lang_search.group(1)}]\"\n                else:\n                    # fallback: detect language from code fences in chunk\n                    fence_lang_search = re.search(r'```(\\w+)', c.page_content)\n                    if fence_lang_search:\n                        lang_tag = f\"[LANG={fence_lang_search.group(1).upper()}]\"\n                    else:\n                        lang_tag = \"[LANG=UNKNOWN]\"\n                c.page_content = f\"{prefix} {lang_tag} {tag_str} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"tags\"] = tag_str\n                c.metadata[\"language\"] = lang_tag.strip(\"[]\").replace(\"LANG=\", \"\").lower()\n                child_chunks.append(c)\n\n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n\n        packed = []\n        requested_lang = None\n        # Detect requested language from query for reranker prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            lang = d.metadata.get(\"language\", \"unknown\")\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the query.\\n\"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query\\n\"\n            \"- Complete API definitions over partial snippets\\n\"\n            \"- Code examples in the user's requested programming language\\n\"\n            \"- Proper handling of multi-language snippets\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n\n        # Determine requested language from query for filtering\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query_str, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag if language requested, with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for d in candidates:\n                tags = d.metadata.get(\"tags\", \"\")\n                lang = d.metadata.get(\"language\", \"\").lower()\n                # Match requested language tag in content or metadata tags or language field\n                if (f\"[{requested_lang.upper()}]\" in d.page_content or\n                    f\"[{requested_lang.upper()}]\" in tags or\n                    lang == requested_lang):\n                    filtered_candidates.append(d)\n            # Use filtered candidates only if sufficient count, else fallback to full set\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n\n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n\n        # 3. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML-like tags for clearer source separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 4. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. Only provide code or explanations in the user's requested language if specified; otherwise, default to Python but mention that other languages are available.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n\n        res = self.llm.invoke(prompt)\n        gc.collect()\n\n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.4976, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if found in breadcrumb or source filename\n            tags = []\n            if re.search(r'\\bA2A\\b', breadcrumb, re.I) or 'a2a' in source.lower():\n                tags.append(\"[A2A]\")\n            if re.search(r'\\bWORKFLOW\\b', breadcrumb, re.I) or 'workflow' in source.lower():\n                tags.append(\"[WORKFLOW]\")\n            if tags:\n                p.metadata[\"tags\"] = \" \".join(tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation and language tags if present\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                \n                # Add language tag from breadcrumb if detected\n                lang_tag = \"\"\n                lang_matches = re.findall(r'#### (\\w+) Implementation', c.page_content)\n                if lang_matches:\n                    lang_tag = f\"[{lang_matches[0].upper()}]\"\n                \n                # Add tags from parent metadata\n                tag_str = p.metadata.get(\"tags\", \"\")\n                \n                c.page_content = f\"{prefix} {lang_tag} {tag_str} {breadcrumb}\\n{c.page_content}\".strip()\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with improved prompt for multi-language and completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            lang_tag = d.metadata.get(\"language\", \"unknown\").lower()\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Extract JSON robustly if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 3. Parent Retrieval & Formatting with XML-style tags and language filtering\n        final_contexts = []\n        seen_parents = set()\n        context_blocks = []\n        \n        # Detect requested language from query (case-insensitive)\n        requested_lang = None\n        lang_candidates = ['python', 'go', 'java']\n        query_lower = query_str.lower()\n        for lang in lang_candidates:\n            if re.search(r'\\b' + lang + r'\\b', query_lower):\n                requested_lang = lang\n                break\n        \n        def chunk_language_filter(chunk_text: str) -> bool:\n            # Simple heuristic: check for language tags or code fences\n            if requested_lang is None:\n                return True\n            lang_tag = requested_lang.capitalize()\n            if f\"#### {lang_tag} Implementation\" in chunk_text:\n                return True\n            # Also accept if chunk mentions requested language in prefix or breadcrumb\n            if re.search(r'\\[' + requested_lang.upper() + r'\\]', chunk_text, re.I):\n                return True\n            # If chunk is code and no explicit language, accept by default\n            if chunk_text.startswith(\"[DOC_CODE]\"):\n                return True\n            return False\n        \n        for c in top_chunks:\n            if not chunk_language_filter(c.page_content):\n                continue\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent by language as well\n                if not chunk_language_filter(parent.page_content):\n                    continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                context_blocks.append(f\"<source file='{src}' section='{breadcrumb}'>\\n{parent.page_content}\\n</source>\")\n        \n        context_block = \"\\n\\n\".join(context_blocks)\n        \n        # 4. Generation (Strict Grounding) with improved prompt encouraging Quote then Explain and language adherence\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context.\\n\"\n            \"Rules:\\n\"\n            \"1. If the answer is not contained within the context, respond exactly: 'I don't know from the provided documentation'.\\n\"\n            \"2. Always mention API classes or methods using the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' approach: first quote the relevant passage or code, then provide your explanation.\\n\"\n            \"4. Only provide code snippets or examples in the user-requested programming language (Python, Go, Java). If no language is requested, default to Python but acknowledge other languages exist in the docs.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n# Current Program\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags to help reranker identify language and completeness\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                # Try detect language from breadcrumb or content heuristics\n                if re.search(r'```python', d.page_content, re.I):\n                    lang_tag = \"[LANG=Python]\"\n                elif re.search(r'```go', d.page_content, re.I):\n                    lang_tag = \"[LANG=Go]\"\n                elif re.search(r'```java', d.page_content, re.I):\n                    lang_tag = \"[LANG=Java]\"\n            # Detect if chunk likely contains a complete API definition or partial snippet\n            completeness_tag = \"[COMPLETE]\" if re.search(\n                r'^\\s*(class|func|interface|def|type|package|func\\s+main)\\s', d.page_content, re.I|re.M) else \"[PARTIAL]\"\n            \n            content_snippet = d.page_content[:1300].replace('\\n', ' ')\n            packed.append(f\"[{i}] {lang_tag} {completeness_tag} {content_snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 on relevance to the query, prioritizing:\\n\"\n            \"1) Exact API names or full definitions over partial snippets.\\n\"\n            \"2) Code examples executable in the requested language.\\n\"\n            \"3) Language requested by user query (detect language tags).\\n\"\n            \"4) Prefer chunks with complete API definitions or full function/class blocks.\\n\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON ONLY with format: {'scores': {chunk_id: score, ...}}\\n\"\n            \"Scores must be integers 0 to 100.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, combined_score\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n=======\n        # Refined hyperparameters for better synergy: smaller chunks, balanced recall/precision\n        self.chunk_size = 400  # smaller chunk size for finer granularity on API docs\n        self.chunk_overlap = 80  # overlap reduced for more distinct chunks\n        self.top_k_vector = 25  # increase vector top_k to boost recall of conceptual docs\n        self.top_k_bm25 = 30    # increase BM25 top_k to capture exact API mentions better\n        self.weight_vector = 0.4  # slight preference to BM25 due to many exact API names\n        self.weight_bm25 = 0.6\n        self.rerank_top_n = 10  # increase rerank candidate set for LLM to select from\n        self.temperature = 0.0\n        self.expand_query = False \n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers.\"\"\"\n        # Simple regex for {% tab label=\"Python\" %} blocks\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1)\n            content = match.group(2)\n            return f\"\\n\\n#### {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n=======\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n            # Add tagging for better semantic separation\n            prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n            # Detect language from code fences for tagging\n            lang_tag = \"\"\n            lang_match = re.search(r'```(\\w+)', c.page_content)\n            if lang_match:\n                lang = lang_match.group(1).lower()\n                if lang in (\"python\", \"go\", \"java\"):\n                    lang_tag = f\"[LANG={lang.capitalize()}]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n            else:\n                lang_tag = \"[LANG=Unknown]\"\n            # Add tags and breadcrumb into chunk content for better reranking and generation\n            c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n            c.metadata[\"parent_id\"] = parent_id\n            c.metadata[\"source\"] = source\n            child_chunks.append(c)\n=======\n            # Add tagging for better semantic separation\n            prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n            # Detect language from code fences or markdown tabs for tagging\n            lang_tag = \"\"\n            # Try detect language tag from markdown header inside chunk\n            md_lang_match = re.search(r'\\[([A-Z]+)\\]\\s+\\w+\\s+Implementation', c.page_content)\n            if md_lang_match:\n                lang_tag = f\"[LANG={md_lang_match.group(1).capitalize()}]\"\n            else:\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n            # Compose chunk content with tags for reranking and generation synergy\n            c.page_content = f\"{prefix} {lang_tag} {p.metadata.get('tags','')} {breadcrumb}\\n{c.page_content}\"\n            c.metadata[\"parent_id\"] = parent_id\n            c.metadata[\"source\"] = source\n            c.metadata[\"language\"] = lang_tag.strip(\"[]\").replace(\"LANG=\", \"\").lower()\n            c.metadata[\"tags\"] = p.metadata.get(\"tags\", \"\")\n            child_chunks.append(c)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        packed = []\n        for i, d in enumerate(docs):\n            # Include metadata tags to help reranker identify language and completeness\n            lang_tag = \"[LANG=Unknown]\"\n            if \"[DOC_CODE]\" in d.page_content:\n                # Try detect language from breadcrumb or content heuristics\n                if re.search(r'```python', d.page_content, re.I):\n                    lang_tag = \"[LANG=Python]\"\n                elif re.search(r'```go', d.page_content, re.I):\n                    lang_tag = \"[LANG=Go]\"\n                elif re.search(r'```java', d.page_content, re.I):\n                    lang_tag = \"[LANG=Java]\"\n            # Detect if chunk likely contains a complete API definition or partial snippet\n            completeness_tag = \"[COMPLETE]\" if re.search(\n                r'^\\s*(class|func|interface|def|type|package|func\\s+main)\\s', d.page_content, re.I|re.M) else \"[PARTIAL]\"\n            \n            content_snippet = d.page_content[:1300].replace('\\n', ' ')\n            packed.append(f\"[{i}] {lang_tag} {completeness_tag} {content_snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 on relevance to the query, prioritizing:\\n\"\n            \"1) Exact API names or full definitions over partial snippets.\\n\"\n            \"2) Code examples executable in the requested language.\\n\"\n            \"3) Language requested by user query (detect language tags).\\n\"\n            \"4) Prefer chunks with complete API definitions or full function/class blocks.\\n\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON ONLY with format: {'scores': {chunk_id: score, ...}}\\n\"\n            \"Scores must be integers 0 to 100.\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: return docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n=======\n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Exact API names matching the query.\\n\"\n            \"- Complete API definitions over partial snippets.\\n\"\n            \"- Code examples in the user's requested programming language if specified.\\n\"\n            \"- Proper handling of multi-language snippets.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return a JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n=======\n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n=======\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n=======\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE"]}}, "artifacts_json": "{\"raw_scores\": [0.5, 0.47, 0.5, 0.68125, 0.5875, 0.685, 0.675, 0.6380952380952382, 0.525, 0.43333333333333335], \"error_details\": [{\"sample\": 1, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 8: name 'Event' is not defined\\\"]\", \"bad_code\": \"# Simplified view of logic inside Agent.run_async, callbacks, or tools\\n\\n# ... previous code runs based on current state ...\\n\\n# 1. Determine a change or output is needed, construct the event\\n# Example: Updating state\\nupdate_data = {'field_1': 'value_2'}\\nevent_with_state_change = Event(\\n    author=self.name,\\n    actions=EventActions(state_delta=update_data),\\n    content=types.Content(parts=[types.Part(text=\\\"State updated.\\\")])\\n    # ... other event fields ...\\n)\\n\\n# 2. Yield the event to the Runner for processing & commit\\nyield event_with_state_change\\n# <<<<<<<<<<<< EXECUTION PAUSES HERE >>>>>>>>>>>>\\n\\n# <<<<<<<<<<<< RUNNER PROCESSES & COMMITS THE EVENT >>>>>>>>>>>>\\n\\n# 3. Resume execution ONLY after Runner is done processing the above event.\\n# Now, the state committed by the Runner is reliably reflected.\\n# Subsequent code can safely assume the change from the yielded event happened.\\nval = ctx.session.state['field_1']\\n# here `val` is guaranteed to be \\\"value_2\\\" (assuming Runner committed successfully)\\nprint(f\\\"Resumed execution. Value of field_1 is now: {val}\\\")\\n\\n# ... subsequent code continues ...\\n# Maybe yield another event later...\"}, {\"sample\": 3, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 7: name 'get_time' is not defined\\\", \\\"Instantiation Error on line 43: name 'get_time' is not defined\\\"]\", \"bad_code\": \"# Core abstractions: wrap a function as a tool.\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\\\"time\\\": \\\"12:00\\\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\\\"get_time\\\")\\n\\ndef lookup_order_status(order_id: str) -> dict:\\n    \\\"\\\"\\\"Fetches the current status of a customer's order using its ID.\\n\\n    Use this tool ONLY when a user explicitly asks for the status of\\n    a specific order and provides the order ID. Do not use it for\\n    general inquiries.\\n\\n    Args:\\n        order_id: The unique identifier of the order to look up.\\n\\n    Returns:\\n        A dictionary indicating the outcome.\\n        On success, status is 'success' and includes an 'order' dictionary.\\n        On failure, status is 'error' and includes an 'error_message'.\\n        Example success: {'status': 'success', 'order': {'state': 'shipped', 'tracking_number': '1Z9...'}}\\n        Example error: {'status': 'error', 'error_message': 'Order ID not found.'}\\n    \\\"\\\"\\\"\\n    # ... function implementation to fetch status ...\\n    if status_details := fetch_status_from_backend(order_id):\\n        return {\\n            \\\"status\\\": \\\"success\\\",\\n            \\\"order\\\": {\\n                \\\"state\\\": status_details.state,\\n                \\\"tracking_number\\\": status_details.tracking,\\n            },\\n        }\\n    else:\\n        return {\\\"status\\\": \\\"error\\\", \\\"error_message\\\": f\\\"Order ID {order_id} not found.\\\"}\\n\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\\\"time\\\": \\\"12:00\\\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\\\"get_time\\\")\"}, {\"sample\": 4, \"type\": \"code_error\", \"message\": \"Syntax Error: invalid syntax (<unknown>, line 56)\", \"bad_code\": \"# Complete Python example to run an LlmAgent that answers questions,\\n# including all necessary imports and correct execution.\\n\\nimport asyncio\\nfrom google.adk.agents import LlmAgent\\nfrom google.adk.runners import Runner\\nfrom google.adk.sessions import InMemorySessionService\\nfrom google.genai import types\\n\\n# --- 1. Define constants ---\\nAPP_NAME = \\\"simple_qa_app\\\"\\nUSER_ID = \\\"user_123\\\"\\nSESSION_ID = \\\"session_abc\\\"\\nMODEL_NAME = \\\"gemini-2.0-flash\\\"\\n\\n# --- 2. Create the LlmAgent ---\\nagent = LlmAgent(\\n    model=MODEL_NAME,\\n    name=\\\"simple_qa_agent\\\",\\n    instruction=\\\"You are a helpful assistant that answers questions clearly.\\\"\\n)\\n\\n# --- 3. Set up session service and runner ---\\nsession_service = InMemorySessionService()\\n\\n# Create a session (optional but recommended for state management)\\nasync def create_session():\\n    await session_service.create_session(app_name=APP_NAME, user_id=USER_ID, session_id=SESSION_ID)\\n\\n# Create a runner to run the agent\\nrunner = Runner(agent=agent, app_name=APP_NAME, session_service=session_service)\\n\\n# --- 4. Define async function to send query and print response ---\\nasync def call_agent_and_print(query: str):\\n    print(f\\\"\\\\n>>> Sending query to agent: {query}\\\")\\n    user_content = types.Content(role='user', parts=[types.Part(text=query)])\\n\\n    final_response = \\\"No response received.\\\"\\n    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=user_content):\\n        if event.is_final_response() and event.content and event.content.parts:\\n            final_response = event.content.parts[0].text\\n\\n    print(f\\\"<<< Agent response:\\\\n{final_response}\\\")\\n\\n# --- 5. Main async entry point ---\\nasync def main():\\n    await create_session()\\n    # Example question\\n    await call_agent_and_print(\\\"What is the capital of France?\\\")\\n    await call_agent_and_print(\\\"Who wrote 'Pride and Prejudice'?\\\")\\n\\n# --- 6. Run the main function ---\\nif __name__ == \\\"__main__\\\":\\n    asyncio.run(main())\\n\\n> from google.adk.agents import LlmAgent\\n>\\n> agent = LlmAgent(\\n> model=\\\"gemini-2.0-flash\\\",\\n> name=\\\"my_agent\\\",\\n> instruction=\\\"You are a helpful assistant.\\\",\\n> tools=[my_tool_function]\\n> )\\n>\\n\\n> session_service = InMemorySessionService()\\n> runner = Runner(agent=agent, app_name=APP_NAME, session_service=session_service)\\n>\"}, {\"sample\": 5, \"type\": \"code_error\", \"message\": \"Syntax Error: invalid syntax (<unknown>, line 32)\", \"bad_code\": \"# Python example of a Custom Agent routing to different sub-agents based on session state\\n\\nfrom typing import AsyncGenerator\\nfrom google.adk.agents import BaseAgent\\nfrom google.adk.types import InvocationContext, Event\\n\\nclass RoutingCustomAgent(BaseAgent):\\n    def __init__(self, sub_agent_a, sub_agent_b):\\n        # Pass sub-agents list to BaseAgent constructor for lifecycle management\\n        super().__init__(sub_agents=[sub_agent_a, sub_agent_b])\\n        self.sub_agent_a = sub_agent_a\\n        self.sub_agent_b = sub_agent_b\\n\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        # Access session state\\n        route_key = ctx.session.state.get(\\\"route_key\\\")\\n\\n        if route_key == \\\"use_a\\\":\\n            # Route to sub_agent_a\\n            async for event in self.sub_agent_a.run_async(ctx):\\n                yield event\\n        elif route_key == \\\"use_b\\\":\\n            # Route to sub_agent_b\\n            async for event in self.sub_agent_b.run_async(ctx):\\n                yield event\\n        else:\\n            # Default behavior or fallback\\n            # For example, yield a custom event or call sub_agent_a by default\\n            async for event in self.sub_agent_a.run_async(ctx):\\n                yield event\\n\\n> async for event in self.some_sub_agent.run_async(ctx):\\n>     yield event\\n>\\n\\n> previous_result = ctx.session.state.get(\\\"some_key\\\")\\n> if previous_result == \\\"some_value\\\":\\n>     # call a specific sub-agent\\n> else:\\n>     # call another sub-agent\\n>\"}, {\"sample\": 6, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 14: name 'update_user_preference' is not defined\\\"]\", \"bad_code\": \"from google.adk.tools import ToolContext, FunctionTool\\n\\ndef update_user_preference(preference: str, value: str, tool_context: ToolContext):\\n    \\\"\\\"\\\"Updates a user-specific preference.\\\"\\\"\\\"\\n    user_prefs_key = \\\"user:preferences\\\"\\n    # Get current preferences or initialize if none exist\\n    preferences = tool_context.state.get(user_prefs_key, {})\\n    preferences[preference] = value\\n    # Write the updated dictionary back to the state\\n    tool_context.state[user_prefs_key] = preferences\\n    print(f\\\"Tool: Updated user preference '{preference}' to '{value}'\\\")\\n    return {\\\"status\\\": \\\"success\\\", \\\"updated_preference\\\": preference}\\n\\npref_tool = FunctionTool(func=update_user_preference)\\n\\n# In an Agent:\\n# my_agent = Agent(..., tools=[pref_tool])\\n\\n# When the LLM calls update_user_preference(preference='theme', value='dark', ...):\\n# The tool_context.state will be updated, and the change will be part of the\\n# resulting tool response event's actions.state_delta.\"}, {\"sample\": 7, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 2: No module named 'google.adk.runner'\\\", \\\"Import Error on line 5: No module named 'rx'\\\"]\", \"bad_code\": \"from google.adk.agents import SequentialAgent, LlmAgent\\nfrom google.adk.runner import InMemoryRunner\\nfrom google.adk.sessions import Session\\nfrom google.genai.types import Content, Part\\nfrom rx import operators as ops\\n\\n# --- 1. Define Sub-Agents for Each Pipeline Stage ---\\n\\n# Code Writer Agent\\ncode_writer_agent = LlmAgent(\\n    name=\\\"CodeWriterAgent\\\",\\n    model=\\\"GEMINI_MODEL\\\",\\n    instruction=\\\"\\\"\\\"You are a Python Code Generator.\\nBased *only* on the user's request, write Python code that fulfills the requirement.\\nOutput *only* the complete Python code block, enclosed in triple backticks (\\n\\n).\\nDo not add any other text before or after the code block.\\n\\\"\\\"\\\",\\n    description=\\\"Writes initial Python code based on a specification.\\\",\\n    output_key=\\\"generated_code\\\"  # Stores output in state['generated_code']\\n)\\n\\n# Code Reviewer Agent\\ncode_reviewer_agent = LlmAgent(\\n    name=\\\"CodeReviewerAgent\\\",\\n    model=\\\"GEMINI_MODEL\\\",\\n    instruction=\\\"\\\"\\\"You are an expert Python Code Reviewer.\\nYour task is to provide constructive feedback on the provided code.\\n\\n**Code to Review:**\\n\\n**Review Criteria:**\\n1.  **Correctness:** Does the code work as intended? Are there logic errors?\\n2.  **Readability:** Is the code clear and easy to understand? Follows PEP 8 style guidelines?\\n3.  **Efficiency:** Is the code reasonably efficient? Any obvious performance bottlenecks?\\n4.  **Edge Cases:** Does the code handle potential edge cases or invalid inputs gracefully?\\n5.  **Best Practices:** Does the code follow common Python best practices?\\n\\n**Output:**\\nProvide your feedback as a concise, bulleted list. Focus on the most important points for improvement.\\nIf the code is excellent and requires no changes, simply state: \\\"No major issues found.\\\"\\nOutput *only* the review comments or the \\\"No major issues\\\" statement.\\n\\\"\\\"\\\",\\n    description=\\\"Reviews code and provides feedback.\\\",\\n    output_key=\\\"review_comments\\\",  # Stores output in state['review_comments']\\n)\\n\\n# Code Refactorer Agent\\ncode_refactorer_agent = LlmAgent(\\n    name=\\\"CodeRefactorerAgent\\\",\\n    model=\\\"GEMINI_MODEL\\\",\\n    instruction=\\\"\\\"\\\"You are a Python Code Refactoring AI.\\nYour goal is to improve the given Python code based on the provided review comments.\\n\\n**Original Code:**\\n\\n**Review Comments:**\\n{review_comments}\\n\\n**Task:**\\nCarefully apply the suggestions from the review comments to refactor the original code.\\nIf the review comments state \\\"No major issues found,\\\" return the original code unchanged.\\nEnsure the final code is complete, functional, and includes necessary imports and docstrings.\\n\\n**Output:**\\nOutput *only* the final, refactored Python code block, enclosed in triple backticks (\\n\\n).\\nDo not add any other text before or after the code block.\\n\\\"\\\"\\\",\\n    description=\\\"Refactors code based on review comments.\\\",\\n    output_key=\\\"refactored_code\\\",  # Stores output in state['refactored_code']\\n)\\n\\n# --- 2. Create the SequentialAgent ---\\ncode_pipeline_agent = SequentialAgent(\\n    name=\\\"CodePipelineAgent\\\",\\n    sub_agents=[code_writer_agent, code_reviewer_agent, code_refactorer_agent],\\n    description=\\\"Executes a sequence of code writing, reviewing, and refactoring.\\\",\\n)\\n\\n# --- 3. Run the agent with InMemoryRunner ---\\ndef run_pipeline(prompt: str):\\n    runner = InMemoryRunner(code_pipeline_agent, \\\"CodePipelineAgent\\\")\\n    session = runner.session_service().create_session(\\\"CodePipelineAgent\\\", \\\"user_123\\\").blocking_first()\\n    user_message = Content.from_parts(Part.from_text(prompt))\\n    event_stream = runner.run_async(\\\"user_123\\\", session.id, user_message)\\n\\n    # Collect and print final response from the pipeline\\n    def on_event(event):\\n        if event.final_response():\\n            print(event.stringify_content())\\n\\n    event_stream.subscribe(on_event)\\n\\n# Example usage\\nif __name__ == \\\"__main__\\\":\\n    run_pipeline(\\\"Write a Python function to compute the Fibonacci sequence.\\\")\"}, {\"sample\": 8, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 15: name 'CheckCondition' is not defined\\\", \\\"Instantiation Error on line 40: name 'CheckCondition' is not defined\\\"]\", \"bad_code\": \"# Conceptual Example: Loop with Condition\\nfrom google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckCondition(BaseAgent): # Custom agent to check state\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        status = ctx.session.state.get(\\\"status\\\", \\\"pending\\\")\\n        is_done = (status == \\\"completed\\\")\\n        yield Event(author=self.name, actions=EventActions(escalate=is_done)) # Escalate if done\\n\\nprocess_step = LlmAgent(name=\\\"ProcessingStep\\\") # Agent that might update state['status']\\n\\npoller = LoopAgent(\\n    name=\\\"StatusPoller\\\",\\n    max_iterations=10,\\n    sub_agents=[process_step, CheckCondition(name=\\\"Checker\\\")]\\n)\\n# When poller runs, it executes process_step then Checker repeatedly\\n# until Checker escalates (state['status'] == 'completed') or 10 iterations pass.\\n\\nfrom google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckCondition(BaseAgent):\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        # Check some condition in the shared session state\\n        status = ctx.session.state.get(\\\"status\\\", \\\"pending\\\")\\n        # If condition met, escalate to exit loop early\\n        is_done = (status == \\\"completed\\\")\\n        yield Event(author=self.name, actions=EventActions(escalate=is_done))\\n\\n# Example processing agent that updates state['status']\\nprocess_step = LlmAgent(name=\\\"ProcessingStep\\\")\\n\\n# LoopAgent runs process_step and then CheckCondition repeatedly\\nretry_loop = LoopAgent(\\n    name=\\\"RetryLoop\\\",\\n    max_iterations=10,\\n    sub_agents=[process_step, CheckCondition(name=\\\"Checker\\\")]\\n)\"}, {\"sample\": 9, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 86: name 'GEMINI_2_FLASH' is not defined\\\", \\\"Instantiation Error on line 94: name 'GEMINI_2_FLASH' is not defined\\\", \\\"Instantiation Error on line 102: name 'StoryToneAgent' is not defined\\\"]\", \"bad_code\": \"import logging\\nfrom typing import AsyncGenerator\\nfrom typing_extensions import override\\n\\nfrom google.adk.agents import LlmAgent, BaseAgent\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom google.adk.events import Event\\n\\nlogger = logging.getLogger(__name__)\\nlogging.basicConfig(level=logging.INFO)\\n\\nclass StoryToneAgent(BaseAgent):\\n    \\\"\\\"\\\"\\n    Custom agent that orchestrates a story generation workflow:\\n    1. Generate a story.\\n    2. Check the tone.\\n    3. Regenerate the story if the tone is negative.\\n    \\\"\\\"\\\"\\n\\n    story_generator: LlmAgent\\n    tone_check: LlmAgent\\n\\n    model_config = {\\\"arbitrary_types_allowed\\\": True}\\n\\n    def __init__(self, name: str, story_generator: LlmAgent, tone_check: LlmAgent):\\n        \\\"\\\"\\\"\\n        Initializes the StoryToneAgent.\\n\\n        Args:\\n            name: The name of the agent.\\n            story_generator: An LlmAgent to generate the story.\\n            tone_check: An LlmAgent to analyze the tone.\\n        \\\"\\\"\\\"\\n        sub_agents_list = [story_generator, tone_check]\\n        super().__init__(\\n            name=name,\\n            story_generator=story_generator,\\n            tone_check=tone_check,\\n            sub_agents=sub_agents_list,\\n        )\\n\\n    @override\\n    async def _run_async_impl(\\n        self, ctx: InvocationContext\\n    ) -> AsyncGenerator[Event, None]:\\n        logger.info(f\\\"[{self.name}] Starting story generation workflow.\\\")\\n\\n        # 1. Generate the story\\n        logger.info(f\\\"[{self.name}] Running StoryGenerator...\\\")\\n        async for event in self.story_generator.run_async(ctx):\\n            logger.info(f\\\"[{self.name}] Event from StoryGenerator: {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n            yield event\\n\\n        # Check if story was generated before proceeding\\n        if \\\"current_story\\\" not in ctx.session.state or not ctx.session.state[\\\"current_story\\\"]:\\n            logger.error(f\\\"[{self.name}] Failed to generate initial story. Aborting workflow.\\\")\\n            return  # Stop processing if no story generated\\n\\n        logger.info(f\\\"[{self.name}] Story state after generation: {ctx.session.state.get('current_story')}\\\")\\n\\n        # 2. Check the tone\\n        logger.info(f\\\"[{self.name}] Running ToneCheck...\\\")\\n        async for event in self.tone_check.run_async(ctx):\\n            logger.info(f\\\"[{self.name}] Event from ToneCheck: {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n            yield event\\n\\n        tone_check_result = ctx.session.state.get(\\\"tone_check_result\\\")\\n        logger.info(f\\\"[{self.name}] Tone check result: {tone_check_result}\\\")\\n\\n        # 3. Regenerate story if tone is negative\\n        if tone_check_result == \\\"negative\\\":\\n            logger.info(f\\\"[{self.name}] Tone is negative. Regenerating story...\\\")\\n            async for event in self.story_generator.run_async(ctx):\\n                logger.info(f\\\"[{self.name}] Event from StoryGenerator (Regen): {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n                yield event\\n        else:\\n            logger.info(f\\\"[{self.name}] Tone is not negative. Keeping current story.\\\")\\n\\n        logger.info(f\\\"[{self.name}] Workflow finished.\\\")\\n\\n\\n# Example usage: define the LlmAgents and instantiate the custom agent\\n\\nGEMINI_2_FLASH = \\\"gemini-2.0-flash\\\"\\n\\nstory_generator = LlmAgent(\\n    name=\\\"StoryGenerator\\\",\\n    model=GEMINI_2_FLASH,\\n    instruction=\\\"You are a story writer. Write a short story (around 100 words) on the following topic: {topic}\\\",\\n    input_schema=None,\\n    output_key=\\\"current_story\\\",\\n)\\n\\ntone_check = LlmAgent(\\n    name=\\\"ToneCheck\\\",\\n    model=GEMINI_2_FLASH,\\n    instruction=\\\"You are a tone analyzer. Analyze the tone of the story provided: {current_story}. Output only one word: 'positive' if the tone is generally positive, 'negative' if the tone is generally negative, or 'neutral' otherwise.\\\",\\n    input_schema=None,\\n    output_key=\\\"tone_check_result\\\",\\n)\\n\\nstory_tone_agent = StoryToneAgent(\\n    name=\\\"StoryToneAgent\\\",\\n    story_generator=story_generator,\\n    tone_check=tone_check,\\n)\"}]}", "artifact_dir": null, "embedding": null}