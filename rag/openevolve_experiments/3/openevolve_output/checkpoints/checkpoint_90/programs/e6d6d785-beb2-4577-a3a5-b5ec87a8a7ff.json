{"id": "e6d6d785-beb2-4577-a3a5-b5ec87a8a7ff", "code": "import os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            # Normalize language tags for synergy\n            if language in (\"python\", \"py\"):\n                language = \"python\"\n            elif language in (\"golang\", \"go\"):\n                language = \"go\"\n            elif language == \"java\":\n                language = \"java\"\n            else:\n                language = \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path, with prioritization\n            breadcrumb_lower = breadcrumb.lower()\n            source_lower = source.lower()\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb_lower) or re.search(r'\\b(a2a|auth)\\b', source_lower):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb_lower) or re.search(r'\\bworkflow\\b', source_lower):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Add explicit language tag into chunk content for reranker synergy\n                lang_tag = f\"[LANG={language.capitalize()}]\" if language != \"unknown\" else \"[LANG=Unknown]\"\n                # Add explicit project_area tag inside chunk content for synergy\n                project_area = p.metadata.get(\"project_area\", \"[GENERAL]\")\n                c.page_content = f\"{prefix} {lang_tag} {project_area} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = project_area\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: \n                # Fallback heuristic: score by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    # Bonus: prefer chunks with project area tags if query contains project area keywords\n                    project_area_keywords = {\n                        \"a2a\": \"[A2A]\",\n                        \"auth\": \"[A2A]\",\n                        \"workflow\": \"[WORKFLOW]\"\n                    }\n                    for kw, tag in project_area_keywords.items():\n                        if kw in query.lower() and tag.lower() in content:\n                            score += 10\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag in metadata or content with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for c in candidates:\n                lang = c.metadata.get(\"language\", \"\").lower()\n                # Accept if language matches or is unknown (for Python default)\n                if lang == requested_lang or (requested_lang == \"python\" and lang == \"unknown\"):\n                    filtered_candidates.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n            else:\n                # Fallback to original set if too few candidates remain\n                candidates = self.retriever.invoke(query_str)\n\n        # 2.5. Expand query if no good candidates found to increase recall, with improved expansion logic\n        if self.expand_query and (not candidates or len(candidates) < 5):\n            def _expand_query(query: str) -> str:\n                base_expansion = \"google adk API usage example\"\n                lower_query = query.lower()\n                if \"google adk\" not in lower_query:\n                    return query + \" \" + base_expansion\n                additions = [\"tutorial\", \"code sample\", \"example\", \"reference\"]\n                for add in additions:\n                    if add not in lower_query:\n                        return query + \" \" + add\n                return query\n\n            expanded_query = _expand_query(query_str)\n            if expanded_query and expanded_query != query_str:\n                candidates = self.retriever.invoke(expanded_query)\n\n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent by language similarly to chunk filtering\n                lang = parent.metadata.get(\"language\", \"\").lower()\n                if requested_lang:\n                    if requested_lang == \"python\" and lang not in (\"python\", \"unknown\"):\n                        continue\n                    elif requested_lang != \"python\" and lang != requested_lang:\n                        continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                # Summarize parent content to first 1000 chars to reduce prompt size\n                parent_summary = parent.page_content[:1000].rstrip()\n                if len(parent.page_content) > 1000:\n                    parent_summary += \"\\n...[truncated]...\\n\"\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent_summary}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\"\n            \"6. When quoting code snippets, explicitly label the language for clarity.\\n\"\n            \"7. Use XML-style tags to separate and identify sources clearly.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n    def _expand_query(self, query: str) -> str:\n        \"\"\"Optional method to expand or rephrase query for broader recall.\"\"\"\n        # Simple heuristic: append \"API usage example\" or \"Google ADK\" to query\n        # to help capture more documents\n        if \"google adk\" not in query.lower():\n            return query + \" google adk API usage example\"\n        return query\n", "language": "python", "parent_id": "b57da6c3-a34b-4955-8ced-3055f0d9c37c", "generation": 7, "timestamp": 1769741393.3268402, "iteration_found": 89, "metrics": {"combined_score": 0.6263869047619048, "num_samples": 10}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 23 lines with 25 lines\nChange 2: Replace 9 lines with 11 lines\nChange 3: Replace 53 lines with 62 lines\nChange 4: Replace 37 lines with 38 lines\nChange 5: Replace 26 lines with 26 lines", "parent_metrics": {"combined_score": 0.5711785714285714, "num_samples": 10}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert RAG system optimizer for Google ADK documentation. Improve the code to maximize RAG-pipeline performance.\n\nThe current architecture uses a **Parent-Child Retrieval** system with **Hybrid Search** and **LLM Reranking**.\n\n### High-Leverage Evolution Points:\n\n1. **Hyperparameter Synergy**: Optimize the balance between `chunk_size` (for retrieval precision), `top_k_vector/bm25` (for recall), and `weight_vector/bm25`. The documentation has many exact API names which may favor BM25, while conceptual \"how-to\" queries favor Vector.\n2. **Reranker Prompt Engineering**: The `_llm_rerank` prompt is critical. Evolve it to better identify relevance, handle multi-language snippets, or detect if a chunk contains a complete API definition vs. a partial snippet.\n3. **Metadata-Rich Ingestion**: Enhance `_chunk_document` to include more context in `breadcrumb` and `tagging`. Consider adding language-specific tags or project-area identifiers (e.g. `[A2A]`, `[WORKFLOW]`) to help the reranker and generator.\n4. **Context Assembly & Prompting**: Optimize the `context_block` formatting in `query`. Experiment with summarizing parent context or using XML-style tags to separate sources. Refine the final generation prompt for better \"Quote then Explain\" adherence.\n5. **Cross-Language Filtering**: Implement logic to detect the user's requested language and prioritize or filter retrieved chunks to reduce cross-language noise.\n\n**STRICT RULES**:\n- **Fork-Safety**: Avoid any top-level imports of `langchain`, `agno`, or `openai`. Use lazy imports inside methods.\n- **Compatibility**: Ensure `evaluate_rag(docs_path, query)` maintains its signature.\n- **Cleanup**: Always call `gc.collect()` after LLM calls or retrieval to maintain memory stability.\n\n**Example Improvement (Reranker Logic)**:\n```python\n# You can evolve the reranker prompt to be more specific:\nprompt = (\n    \"Role: ADK Expert Reranker. \"\n    \"Goal: Select chunks that provide EXECUTABLE code for the query. \"\n    f\"Query: {query}\\n\"\n    \"Chunks: ... \"\n)\n```\n- Maintain `evaluate_rag(docs_path, query)` signature and return keys: `answer`, `contexts`.\n- Keep `RAGSystem` class structure and lazy-loading in `__init__`.\n", "user": "# Current Program Information\n- Fitness: 0.5712\n- Feature coordinates: combined_score=0.57\n- Focus areas: - Fitness declined: 0.6292 \u2192 0.5712. Consider revising recent changes.\n- Exploring combined_score=0.57 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### raw_scores\n```\n[0.06666666666666667, 0.515, 0.62, 0.6875, 0.3928571428571429, 0.8500000000000001, 0.7833333333333334, 0.4130952380952381, 0.5666666666666667, 0.8166666666666667]\n```\n\n### error_details\n```\n[{'sample': 3, 'type': 'code_error', 'message': '[\"Instantiation Error on line 7: name \\'get_time\\' is not defined\", \"Instantiation Error on line 14: name \\'get_time\\' is not defined\"]', 'bad_code': '# Core abstractions: wrap a function as a tool.\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\"time\": \"12:00\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\"get_time\")\\n\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\"time\": \"12:00\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\"get_time\")'}, {'sample': 7, 'type': 'code_error', 'message': '[\"Import Error on line 22: No module named \\'google.adk.runtime\\'\", \"Import Error on line 28: No module named \\'google.adk.runtime\\'\", \"Instantiation Error on line 24: name \\'Runner\\' is not defined\", \"Instantiation Error on line 56: name \\'Runner\\' is not defined\"]', 'bad_code': '# Conceptual Example: Sequential Pipeline\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\n\\nstep1 = LlmAgent(name=\"Step1_Fetch\", output_key=\"data\") # Saves output to state[\\'data\\']\\nstep2 = LlmAgent(name=\"Step2_Process\", instruction=\"Process data from {data}.\")\\n\\npipeline = SequentialAgent(name=\"MyPipeline\", sub_agents=[step1, step2])\\n# When pipeline runs, Step2 can access the state[\\'data\\'] set by Step1.\\n\\n# Conceptual Code: Sequential Data Pipeline\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\n\\nvalidator = LlmAgent(name=\"ValidateInput\", instruction=\"Validate the input.\", output_key=\"validation_status\")\\nprocessor = LlmAgent(name=\"ProcessData\", instruction=\"Process data if {validation_status} is \\'valid\\'.\", output_key=\"result\")\\nreporter = LlmAgent(name=\"ReportResult\", instruction=\"Report the result from {result}.\")\\n\\ndata_pipeline = SequentialAgent(\\n    name=\"DataPipeline\",\\n    sub_agents=[validator, processor, reporter]\\n)\\n\\nfrom google.adk.runtime import Runner\\n\\nrunner = Runner()\\nrunner.run(data_pipeline)\\n\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\nfrom google.adk.runtime import Runner\\n\\n# Define three LlmAgents with output_key to pass data via shared state\\nagent1 = LlmAgent(\\n    name=\"Agent1_Generate\",\\n    instruction=\"Generate initial data.\",\\n    output_key=\"data1\"\\n)\\n\\nagent2 = LlmAgent(\\n    name=\"Agent2_Process\",\\n    instruction=\"Process the data: {data1}\",\\n    output_key=\"data2\"\\n)\\n\\nagent3 = LlmAgent(\\n    name=\"Agent3_Summarize\",\\n    instruction=\"Summarize the processed data: {data2}\",\\n    output_key=\"summary\"\\n)\\n\\n# Create a SequentialAgent pipeline with the three agents\\npipeline = SequentialAgent(\\n    name=\"ThreeStepPipeline\",\\n    sub_agents=[agent1, agent2, agent3]\\n)\\n\\n# Run the pipeline using the Runner\\nrunner = Runner()\\nrunner.run(pipeline)'}, {'sample': 8, 'type': 'code_error', 'message': '[\"Instantiation Error on line 16: name \\'WriterAgent\\' is not defined\", \"Instantiation Error on line 35: name \\'WriterAgent\\' is not defined\"]', 'bad_code': '# Conceptual Code: Iterative Code Refinement\\nfrom google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckingAgent(BaseAgent):\\n    async def run(self, ctx: InvocationContext) -> AsyncGenerator[Event, EventActions]:\\n        # Check some condition in ctx.state\\n        if ctx.state.get(\"quality\") >= 0.9:\\n            yield Event(\"QualityReached\")\\n            return EventActions(escalate=True)  # Signal to stop LoopAgent early\\n        yield Event(\"QualityNotReached\")\\n        return EventActions()\\n\\nloop = LoopAgent(\\n    sub_agents=[WriterAgent(), CriticAgent(), CheckingAgent()],\\n    max_iterations=10\\n)\\n\\nfrom google.adk.agents import LoopAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckingAgent(BaseAgent):\\n    async def run(self, ctx: InvocationContext) -> AsyncGenerator[Event, EventActions]:\\n        # Check some condition in the shared state\\n        if ctx.state.get(\"quality\") >= 0.9:\\n            yield Event(\"QualityReached\")\\n            return EventActions(escalate=True)  # Signal LoopAgent to stop early\\n        yield Event(\"QualityNotReached\")\\n        return EventActions()\\n\\nloop = LoopAgent(\\n    sub_agents=[WriterAgent(), CriticAgent(), CheckingAgent()],\\n    max_iterations=10\\n)'}]\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace 12 lines with 16 lines\nChange 2: Replace 51 lines with 83 lines\nChange 3: Replace 48 lines with 63 lines\n- Metrics: combined_score: 0.6292, num_samples: 10.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 28 lines with 32 lines\nChange 2: Replace 54 lines with 56 lines\nChange 3: Replace 16 lines with 16 lines\nChange 4: Replace 20 lines with 22 lines\nChange 5: Replace 11 lines with 12 lines\n- Metrics: combined_score: 0.6367, num_samples: 10.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace 9 lines with 11 lines\nChange 2: Replace 10 lines with 11 lines\nChange 3: Replace 21 lines with 24 lines\nChange 4: Replace 47 lines with 47 lines\nChange 5: Replace 28 lines with 31 lines\nChange 6: Replace 45 lines with 46 lines\n- Metrics: combined_score: 0.6422, num_samples: 10.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.6422)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Append a standardized language tag for chunk tagging synergy\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                # Also add project area tag into chunk content for reranker synergy\n                project_area = p.metadata.get(\"tags\", \"[GENERAL]\")\n                c.page_content = f\"{prefix} {lang_tag} {project_area} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"project_area\"] = project_area\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the query.\\n\"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query\\n\"\n            \"- Complete API definitions over partial snippets\\n\"\n            \"- Code examples in the user's requested programming language\\n\"\n            \"- Proper handling of multi-language snippets\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        else:\n            # If too few, fallback to original for recall preservation\n            pass\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use caching for llm.invoke to reduce latency on repeated queries (optional)\n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.6422), Performs well on num_samples (10.0000)\n\n### Program 2 (Score: 0.6367)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Improve language detection in reranker by parsing chunk content for LANG tag fallback to metadata\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', d.page_content)\n            lang = lang_tag_search.group(1).lower() if lang_tag_search else d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            \n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                # Fallback heuristic: rank by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            # Use word boundary to avoid partial matches\n            if re.search(r'\\b' + lang + r'\\b', lower_query):\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n\n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Normalize language names for comparison\n            chunk_lang_norm = chunk_lang.lower()\n            requested_lang_norm = requested_lang.lower() if requested_lang else \"\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang_norm == \"python\" and chunk_lang_norm in (\"python\", \"unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang_norm == requested_lang_norm:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                parent_lang_norm = parent_lang.lower()\n                requested_lang_norm = requested_lang.lower() if requested_lang else \"\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang_norm == \"python\" and parent_lang_norm not in (\"python\", \"unknown\"):\n                    continue\n                elif requested_lang_norm != \"python\" and parent_lang_norm != requested_lang_norm:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use LLM invoke with retry to improve robustness\n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.6367), Performs well on num_samples (10.0000)\n\n### Program 3 (Score: 0.6292)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang == requested_lang else \"[LANG_OTHER]\"\n            \n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                # Fallback heuristic: rank by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n\n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use LLM invoke with retry to improve robustness\n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.6292), Performs well on num_samples (10.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.6114)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\bA2A\\b', breadcrumb, re.I) or re.search(r'\\ba2a\\b', source, re.I):\n                project_tags.append(\"[A2A]\")\n            if re.search(r'\\bWORKFLOW\\b', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"[GENERAL]\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging, fallback to parent's language tag\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    # fallback to parent's detected language tag if available\n                    parent_lang = p.metadata.get(\"language\", \"unknown\").capitalize()\n                    lang_tag = f\"[LANG={parent_lang}]\" if parent_lang != \"Unknown\" else \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang == requested_lang else \"[LANG_OTHER]\"\n            \n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                # Fallback heuristic: rank by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use LLM invoke with retry to improve robustness\n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n### Program D2 (Score: 0.6237)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Append a standardized language tag for chunk tagging synergy\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            # Add language tags from breadcrumb if present (e.g. [Python], [Go], [Java])\n            lang_tag_match = re.search(r'\\[(Python|Go|Java)\\]', breadcrumb)\n            if lang_tag_match:\n                project_tags.append(f\"[LANG={lang_tag_match.group(1)}]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                # Also add project area tag into chunk content for reranker synergy\n                project_area = p.metadata.get(\"tags\", \"[GENERAL]\")\n                # Also append completeness tag for reranker synergy if chunk contains full API definition\n                completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', c.page_content, re.I) else \"[PARTIAL]\"\n                c.page_content = f\"{prefix} {lang_tag} {project_area} {completeness_tag} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"project_area\"] = project_area\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            # Improve language detection in reranker by parsing chunk content for LANG tag fallback to metadata\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', d.page_content)\n            lang = lang_tag_search.group(1).lower() if lang_tag_search else d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the query.\\n\"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query\\n\"\n            \"- Complete API definitions over partial snippets\\n\"\n            \"- Code examples in the user's requested programming language\\n\"\n            \"- Proper handling of multi-language snippets\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if re.search(r'\\b' + lang + r'\\b', lower_query):\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Normalize language names for comparison\n            chunk_lang_norm = chunk_lang.lower()\n            requested_lang_norm = requested_lang.lower() if requested_lang else \"\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang_norm == \"python\" and chunk_lang_norm in (\"python\", \"unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang_norm == requested_lang_norm:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        else:\n            # If too few, fallback to original for recall preservation\n            pass\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use caching for llm.invoke to reduce latency on repeated queries (optional)\n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Alternative approach to combined_score, Alternative approach to num_samples\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.6422, Type: Alternative)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Append a standardized language tag for chunk tagging synergy\n            return f\"\\n\\n#### [{lang_tag}] {label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                # Also add project area tag into chunk content for reranker synergy\n                project_area = p.metadata.get(\"tags\", \"[GENERAL]\")\n                c.page_content = f\"{prefix} {lang_tag} {project_area} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"project_area\"] = project_area\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Score each chunk from 0 to 100 for relevance to the query.\\n\"\n            \"Prioritize chunks with:\\n\"\n            \"- Exact API names matching the query\\n\"\n            \"- Complete API definitions over partial snippets\\n\"\n            \"- Code examples in the user's requested programming language\\n\"\n            \"- Proper handling of multi-language snippets\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON object with 'scores' mapping chunk IDs to numeric scores.\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                return docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        else:\n            # If too few, fallback to original for recall preservation\n            pass\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use caching for llm.invoke to reduce latency on repeated queries (optional)\n        res = self.llm.invoke(prompt)\n        gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 2 (Score: 0.6367, Type: Alternative)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\[A2A\\]', breadcrumb): project_tags.append(\"[A2A]\")\n            if re.search(r'\\[WORKFLOW\\]', breadcrumb): project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    lang_tag = \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for multi-language & completeness detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Improve language detection in reranker by parsing chunk content for LANG tag fallback to metadata\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', d.page_content)\n            lang = lang_tag_search.group(1).lower() if lang_tag_search else d.metadata.get(\"language\", \"unknown\").lower()\n            requested_lang_tag = \"[REQUESTED_LANG]\" if requested_lang and lang == requested_lang else \"\"\n            \n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {requested_lang_tag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                # Fallback heuristic: rank by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            # Use word boundary to avoid partial matches\n            if re.search(r'\\b' + lang + r'\\b', lower_query):\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n\n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Normalize language names for comparison\n            chunk_lang_norm = chunk_lang.lower()\n            requested_lang_norm = requested_lang.lower() if requested_lang else \"\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang_norm == \"python\" and chunk_lang_norm in (\"python\", \"unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang_norm == requested_lang_norm:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                parent_lang_norm = parent_lang.lower()\n                requested_lang_norm = requested_lang.lower() if requested_lang else \"\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang_norm == \"python\" and parent_lang_norm not in (\"python\", \"unknown\"):\n                    continue\n                elif requested_lang_norm != \"python\" and parent_lang_norm != requested_lang_norm:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use LLM invoke with retry to improve robustness\n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], Object-oriented approach, Comprehensive implementation\n\n### Inspiration 3 (Score: 0.5847, Type: Experimental)\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add project-area tags if identifiable from breadcrumb (example)\n            project_tags = []\n            if re.search(r'\\bA2A\\b', breadcrumb, re.I) or re.search(r'\\ba2a\\b', source, re.I):\n                project_tags.append(\"[A2A]\")\n            if re.search(r'\\bWORKFLOW\\b', breadcrumb, re.I) or re.search(r'workflow', source, re.I):\n                project_tags.append(\"[WORKFLOW]\")\n            if project_tags:\n                p.metadata[\"tags\"] = \" \".join(project_tags)\n            else:\n                p.metadata[\"tags\"] = \"[GENERAL]\"\n            \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Detect language from code fences for tagging, fallback to parent's language tag\n                lang_tag = \"\"\n                lang_match = re.search(r'```(\\w+)', c.page_content)\n                if lang_match:\n                    lang = lang_match.group(1).lower()\n                    if lang in (\"python\", \"go\", \"java\"):\n                        lang_tag = f\"[LANG={lang.capitalize()}]\"\n                    else:\n                        lang_tag = \"[LANG=Unknown]\"\n                else:\n                    # fallback to parent's detected language tag if available\n                    parent_lang = p.metadata.get(\"language\", \"unknown\").capitalize()\n                    lang_tag = f\"[LANG={parent_lang}]\" if parent_lang != \"Unknown\" else \"[LANG=Unknown]\"\n                # Add tags and breadcrumb into chunk content for better reranking and generation\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata.get('tags','')}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        requested_lang = None\n        # Detect requested language from query for prompt emphasis\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def|interface|type|package|func\\s+main)\\s+\\w*', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang = d.metadata.get(\"language\", \"unknown\").lower()\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang == requested_lang else \"[LANG_OTHER]\"\n            \n            tags = d.metadata.get(\"tags\", \"\")\n            breadcrumb = d.metadata.get(\"breadcrumb\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Tags:{tags} Breadcrumb:{breadcrumb}\\n{snippet}\")\n\n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n\n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match:\n                # Fallback heuristic: rank by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n\n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            ranked_indices = sorted(range(len(docs)),\n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))),\n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # Detect requested language from query (simple heuristic)\n        requested_lang = None\n        lang_candidates = [\"python\", \"go\", \"java\"]\n        lower_query = query_str.lower()\n        for lang in lang_candidates:\n            if lang in lower_query:\n                requested_lang = lang.capitalize()\n                break\n        if not requested_lang:\n            requested_lang = \"Python\"  # default\n        \n        # 2. Cross-language filtering: filter candidates to requested language if specified\n        filtered_candidates = []\n        for c in candidates:\n            # Use chunk language tag in content or fallback to unknown\n            lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', c.page_content)\n            chunk_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n            # Include chunks with unknown language for Python requests to avoid losing recall\n            if requested_lang == \"Python\" and chunk_lang in (\"Python\", \"Unknown\"):\n                filtered_candidates.append(c)\n            elif chunk_lang == requested_lang:\n                filtered_candidates.append(c)\n        # Use filtered candidates only if enough remain, else fallback to full candidate set\n        if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n            candidates = filtered_candidates\n        \n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent context by language tag similarly\n                lang_tag_search = re.search(r'\\[LANG=(\\w+)\\]', parent.page_content)\n                parent_lang = lang_tag_search.group(1) if lang_tag_search else \"Unknown\"\n                # Accept unknown language parents for Python queries to preserve recall\n                if requested_lang == \"Python\" and parent_lang not in (\"Python\", \"Unknown\"):\n                    continue\n                elif requested_lang != \"Python\" and parent_lang != requested_lang:\n                    continue\n                \n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Wrap each source in XML-style tags for clearer separation\n                context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{parent.page_content}\\n</source>\\n\\n\"\n        \n        # Summarize parent contexts to reduce context length and improve generation relevance\n        def summarize_parent(text: str) -> str:\n            # Keep first 1000 chars plus a note if truncated\n            max_len = 1000\n            if len(text) > max_len:\n                return text[:max_len].rstrip() + \"\\n... [truncated]\"\n            return text\n        \n        summarized_contexts = []\n        for ctx in final_contexts:\n            summarized_contexts.append(summarize_parent(ctx))\n        \n        context_block = \"\"\n        for i, ctx in enumerate(summarized_contexts):\n            p_id = top_chunks[i].metadata.get(\"parent_id\", f\"unknown_{i}\")\n            parent_meta = self.parent_docs.get(p_id)\n            src = os.path.basename(parent_meta.metadata.get(\"source\", \"unknown\")) if parent_meta else \"unknown\"\n            breadcrumb = parent_meta.metadata.get(\"breadcrumb\", \"\") if parent_meta else \"\"\n            context_block += f\"<source file=\\\"{src}\\\" section=\\\"{breadcrumb}\\\">\\n{ctx}\\n</source>\\n\\n\"\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            f\"4. Only provide code or examples in the requested language: {requested_lang}. \"\n            \"If none requested, default to Python but mention other languages exist.\\n\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\\n\"\n            \"6. Use XML tags to indicate sources.\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        # Use LLM invoke with retry to improve robustness\n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], Object-oriented approach\n\n# Current Program\n```python\nimport os\nimport re\nimport gc\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        # Simple caching to avoid re-ingesting for every query if docs path hasn't changed\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n            \n        return _rag_system_cache.query(query)\n    except Exception as e:\n        import traceback\n        traceback.print_exc()\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\n# Imports removed from top-level to prevent parent process initialization\n# They are now lazy-loaded in RAGSystem.__init__ to ensure fork-safety\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.retriever = None\n        self.llm = None\n        self.rerank_llm = None\n        self.parent_docs = {} # storage for parent nodes\n        \n        # Hyperparameters for evolution\n        self.chunk_size = 500 # Smaller chunks for better retrieval precision\n        self.chunk_overlap = 100\n        self.top_k_vector = 20 \n        self.top_k_bm25 = 20\n        self.weight_vector = 0.5\n        self.weight_bm25 = 0.5\n        self.rerank_top_n = 8 \n        self.temperature = 0.0\n        self.expand_query = False \n        \n        # Load env from multiple possible locations\n        env_paths = [\n            os.path.join(os.path.dirname(__file__), '.env'),\n            os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')\n        ]\n        for p in env_paths:\n            if os.path.exists(p):\n                load_dotenv(p)\n                \n        self._initialize_system()\n\n    def _initialize_system(self):\n        from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n        from langchain_core.documents import Document\n        from langchain_community.vectorstores import FAISS\n        from langchain_community.retrievers import BM25Retriever\n        from langchain_classic.retrievers import EnsembleRetriever\n        \n        embeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n        self.llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=self.temperature)\n        self.rerank_llm = ChatOpenAI(model=\"gpt-4.1-mini\", temperature=0)\n        \n        # Ingestion\n        all_chunks = []\n        if os.path.exists(self.docs_dir):\n            for root, dirs, files in os.walk(self.docs_dir):\n                dirs[:] = [d for d in dirs if not d.startswith('.')]\n                for file in files:\n                    if not file.endswith('.md') or file.startswith('.'): continue\n                    file_path = os.path.join(root, file)\n                    try:\n                        with open(file_path, 'r', encoding='utf-8') as f:\n                            text_content = f.read()\n                        \n                        # Apply evolved chunking strategy\n                        chunks = self._chunk_document(text_content, file_path)\n                        all_chunks.extend(chunks)\n                    except Exception as e:\n                        print(f\"Skipping {file_path}: {e}\")\n\n        if not all_chunks:\n            self.retriever = None\n            return\n\n        # Vector Retriever\n        vector_db = FAISS.from_documents(all_chunks, embeddings)\n        vector_retriever = vector_db.as_retriever(search_kwargs={\"k\": self.top_k_vector})\n        \n        # BM25 Retriever\n        bm25_retriever = BM25Retriever.from_documents(all_chunks)\n        bm25_retriever.k = self.top_k_bm25\n        \n        # Hybrid Ensemble (Base retrieval)\n        ensemble_retriever = EnsembleRetriever(\n            retrievers=[vector_retriever, bm25_retriever],\n            weights=[self.weight_vector, self.weight_bm25]\n        )\n        self.retriever = ensemble_retriever\n        \n        gc.collect()\n\n    def _flatten_markdown_tabs(self, text: str) -> str:\n        \"\"\"Unrolls Google-style tab widgets into sequential headers with normalized language tags.\"\"\"\n        # Enhanced regex for {% tab label=\"Python\" %} blocks with language normalization\n        pattern = r'{% tab label=\"(.*?)\" %}(.*?){% endtab %}'\n        def replacement(match):\n            label = match.group(1).strip()\n            content = match.group(2)\n            lang_map = {\"py\": \"Python\", \"python\": \"Python\", \"go\": \"Go\", \"golang\": \"Go\", \"java\": \"Java\"}\n            lang_tag = lang_map.get(label.lower(), label)\n            # Normalize label to title case and add language tag explicitly in header for clarity\n            normalized_label = label.title()\n            return f\"\\n\\n#### [{lang_tag}] {normalized_label} Implementation\\n{content}\\n\"\n        \n        text = re.sub(r'{% tabs %}', '', text)\n        text = re.sub(r'{% endtabs %}', '', text)\n        return re.sub(pattern, replacement, text, flags=re.DOTALL)\n\n    def _chunk_document(self, text: str, source: str) -> List[Any]:\n        from langchain_text_splitters import MarkdownHeaderTextSplitter, RecursiveCharacterTextSplitter\n        from langchain_core.documents import Document\n        import uuid\n        \n        text = self._flatten_markdown_tabs(text)\n        \n        # 1. Split by headers to create Parent documents\n        header_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=[\n            (\"#\", \"h1\"), (\"##\", \"h2\"), (\"###\", \"h3\"), (\"####\", \"h4\")\n        ])\n        parent_docs = header_splitter.split_text(text)\n        \n        child_chunks = []\n        child_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=self.chunk_size,\n            chunk_overlap=self.chunk_overlap,\n            separators=[\"\\n```\", \"\\n\\n\", \"\\n\", \" \", \"\"]\n        )\n        \n        for p in parent_docs:\n            parent_id = str(uuid.uuid4())\n            breadcrumb = \" > \".join([p.metadata.get(f\"h{i}\", \"\") for i in range(1, 5)]).strip(\" > \")\n            p.metadata[\"source\"] = source\n            p.metadata[\"breadcrumb\"] = breadcrumb\n            \n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            # Normalize language tags for synergy\n            if language in (\"python\", \"py\"):\n                language = \"python\"\n            elif language in (\"golang\", \"go\"):\n                language = \"go\"\n            elif language == \"java\":\n                language = \"java\"\n            else:\n                language = \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb, re.I) or re.search(r'\\b(a2a|auth)\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'\\bworkflow\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n            \n            # 2. Split parents into children\n            for c in child_splitter.split_documents([p]):\n                # Add tagging for better semantic separation\n                prefix = \"[DOC_CODE]\" if \"```\" in c.page_content else \"[DOC_TEXT]\"\n                # Add explicit language tag into chunk content for reranker synergy\n                lang_tag = f\"[LANG={language.capitalize()}]\" if language != \"unknown\" else \"[LANG=Unknown]\"\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n\n    def _llm_rerank(self, query: str, docs: List[Any]) -> List[Any]:\n        \"\"\"Rerank candidates using a small LLM with enhanced prompt for language, completeness, and snippet type detection.\"\"\"\n        if not docs: return []\n        \n        packed = []\n        # Detect requested language from query for reranker prompt emphasis\n        requested_lang = None\n        lang_match = re.search(r'\\b(python|go|java)\\b', query, re.I)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n        \n        for i, d in enumerate(docs):\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: \n                # Fallback heuristic: score by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        if not self.retriever:\n            return {\"answer\": \"No documents ingested.\", \"contexts\": []}\n\n        # 1. Retrieval (Hybrid)\n        candidates = self.retriever.invoke(query_str)\n        \n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag in metadata or content with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for c in candidates:\n                lang = c.metadata.get(\"language\", \"\").lower()\n                # Accept if language matches or is unknown (for Python default)\n                if lang == requested_lang or (requested_lang == \"python\" and lang == \"unknown\"):\n                    filtered_candidates.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n            else:\n                # Fallback to original set if too few candidates remain\n                candidates = self.retriever.invoke(query_str)\n\n        # 2.5. Expand query if no good candidates found to increase recall\n        if self.expand_query and (not candidates or len(candidates) < 5):\n            def _expand_query(query: str) -> str:\n                base_expansion = \"google adk API usage example\"\n                if \"google adk\" not in query.lower():\n                    return query + \" \" + base_expansion\n                additions = [\"tutorial\", \"code sample\", \"example\", \"reference\"]\n                for add in additions:\n                    if add not in query.lower():\n                        return query + \" \" + add\n                return query\n\n            expanded_query = _expand_query(query_str)\n            if expanded_query and expanded_query != query_str:\n                candidates = self.retriever.invoke(expanded_query)\n\n        # 3. Reranking\n        top_chunks = self._llm_rerank(query_str, candidates)\n        \n        # 4. Parent Retrieval & Formatting\n        final_contexts = []\n        seen_parents = set()\n        context_block = \"\"\n        \n        # Summarize parent context titles for brevity and clarity\n        for c in top_chunks:\n            p_id = c.metadata.get(\"parent_id\")\n            if p_id in self.parent_docs and p_id not in seen_parents:\n                parent = self.parent_docs[p_id]\n                # Filter parent by language similarly to chunk filtering\n                lang = parent.metadata.get(\"language\", \"\").lower()\n                if requested_lang:\n                    if requested_lang == \"python\" and lang not in (\"python\", \"unknown\"):\n                        continue\n                    elif requested_lang != \"python\" and lang != requested_lang:\n                        continue\n                seen_parents.add(p_id)\n                final_contexts.append(parent.page_content)\n                src = os.path.basename(parent.metadata.get(\"source\", \"unknown\"))\n                breadcrumb = parent.metadata.get(\"breadcrumb\", \"\")\n                # Use XML style tags for clarity and better chunk separation\n                # Summarize parent content to first 1000 chars to reduce prompt size\n                parent_summary = parent.page_content[:1000].rstrip()\n                if len(parent.page_content) > 1000:\n                    parent_summary += \"\\n...[truncated]...\\n\"\n                context_block += (\n                    f\"<source file='{src}' section='{breadcrumb}'>\\n\"\n                    f\"{parent_summary}\\n\"\n                    f\"</source>\\n\\n\"\n                )\n\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\"\n            \"6. When quoting code snippets, explicitly label the language for clarity.\\n\"\n            \"7. Use XML-style tags to separate and identify sources clearly.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n\n    def _expand_query(self, query: str) -> str:\n        \"\"\"Optional method to expand or rephrase query for broader recall.\"\"\"\n        # Simple heuristic: append \"API usage example\" or \"Google ADK\" to query\n        # to help capture more documents\n        if \"google adk\" not in query.lower():\n            return query + \" google adk API usage example\"\n        return query\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, combined_score\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            # Normalize language tags for synergy\n            if language in (\"python\", \"py\"):\n                language = \"python\"\n            elif language in (\"golang\", \"go\"):\n                language = \"go\"\n            elif language == \"java\":\n                language = \"java\"\n            else:\n                language = \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb, re.I) or re.search(r'\\b(a2a|auth)\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb, re.I) or re.search(r'\\bworkflow\\b', source, re.I):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n=======\n            # Add language and project-area tags for better filtering and relevance\n            lang_match = re.search(r'```(\\w+)', p.page_content)\n            language = lang_match.group(1).lower() if lang_match else \"unknown\"\n            # Normalize language tags for synergy\n            if language in (\"python\", \"py\"):\n                language = \"python\"\n            elif language in (\"golang\", \"go\"):\n                language = \"go\"\n            elif language == \"java\":\n                language = \"java\"\n            else:\n                language = \"unknown\"\n            p.metadata[\"language\"] = language\n            \n            # Heuristic project-area tagging based on breadcrumbs or source file path, with prioritization\n            breadcrumb_lower = breadcrumb.lower()\n            source_lower = source.lower()\n            if re.search(r'\\b(a2a|auth)\\b', breadcrumb_lower) or re.search(r'\\b(a2a|auth)\\b', source_lower):\n                p.metadata[\"project_area\"] = \"[A2A]\"\n            elif re.search(r'\\bworkflow\\b', breadcrumb_lower) or re.search(r'\\bworkflow\\b', source_lower):\n                p.metadata[\"project_area\"] = \"[WORKFLOW]\"\n            else:\n                p.metadata[\"project_area\"] = \"[GENERAL]\"\n                \n            self.parent_docs[parent_id] = p\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n                lang_tag = f\"[LANG={language.capitalize()}]\" if language != \"unknown\" else \"[LANG=Unknown]\"\n                c.page_content = f\"{prefix} {lang_tag} {breadcrumb} {p.metadata['project_area']}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = p.metadata[\"project_area\"]\n                child_chunks.append(c)\n                \n        return child_chunks\n=======\n                lang_tag = f\"[LANG={language.capitalize()}]\" if language != \"unknown\" else \"[LANG=Unknown]\"\n                # Add explicit project_area tag inside chunk content for synergy\n                project_area = p.metadata.get(\"project_area\", \"[GENERAL]\")\n                c.page_content = f\"{prefix} {lang_tag} {project_area} {breadcrumb}\\n{c.page_content}\"\n                c.metadata[\"parent_id\"] = parent_id\n                c.metadata[\"source\"] = source\n                c.metadata[\"language\"] = language\n                c.metadata[\"project_area\"] = project_area\n                child_chunks.append(c)\n                \n        return child_chunks\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: \n                # Fallback heuristic: score by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n=======\n            # Heuristic completeness detection for full API defs vs partial snippet\n            snippet = d.page_content[:1400].replace('\\n', ' ').strip()\n            completeness_tag = \"[COMPLETE_API]\" if re.search(r'\\b(class|func|def)\\s+\\w+', snippet, re.I) else \"[PARTIAL]\"\n            \n            # Mark language if available and if matches requested language\n            lang_tag = d.metadata.get(\"language\", \"unknown\")\n            lang_flag = \"[LANG_MATCH]\" if requested_lang and lang_tag == requested_lang else \"[LANG_OTHER]\"\n            \n            meta = d.metadata.get(\"breadcrumb\", \"\") + \" \" + d.metadata.get(\"source\", \"\")\n            packed.append(f\"[{i}] {completeness_tag} {lang_flag} Metadata: {meta}\\nContent: {snippet}\")\n        \n        prompt = (\n            \"Role: ADK Expert Reranker.\\n\"\n            \"Goal: Assign a relevance score (0-100) to each chunk for the user query.\\n\"\n            \"Prioritize:\\n\"\n            \"- Chunks containing complete API definitions or well-formed code examples.\\n\"\n            \"- Chunks with exact API names matching the query.\\n\"\n            \"- Chunks in the user's requested programming language if specified (Python, Go, Java).\\n\"\n            \"- Penalize partial snippets and chunks in other languages.\\n\"\n            f\"User Query: {query}\\n\\n\"\n            \"Chunks:\\n\" + \"\\n\\n\".join(packed) + \"\\n\\n\"\n            \"Return JSON with 'scores' mapping chunk_id to score (0-100).\"\n        )\n        \n        try:\n            import json\n            res = self.rerank_llm.invoke(prompt)\n            # Use regex to find JSON if model adds fluff\n            match = re.search(r'\\{.*\\}', res.content, re.DOTALL)\n            if not match: \n                # Fallback heuristic: score by presence of requested language and completeness\n                def score_heuristic(doc):\n                    score = 0\n                    content = doc.page_content.lower()\n                    if requested_lang and f\"[lang={requested_lang}]\" in content:\n                        score += 50\n                    if re.search(r'\\b(class|func|def)\\b', content):\n                        score += 30\n                    if query.lower() in content:\n                        score += 20\n                    # Bonus: prefer chunks with project area tags if query contains project area keywords\n                    project_area_keywords = {\n                        \"a2a\": \"[A2A]\",\n                        \"auth\": \"[A2A]\",\n                        \"workflow\": \"[WORKFLOW]\"\n                    }\n                    for kw, tag in project_area_keywords.items():\n                        if kw in query.lower() and tag.lower() in content:\n                            score += 10\n                    return score\n                scored_docs = sorted(docs, key=score_heuristic, reverse=True)\n                return scored_docs[:self.rerank_top_n]\n            \n            scores = json.loads(match.group(0)).get(\"scores\", {})\n            # Rank indices by score\n            ranked_indices = sorted(range(len(docs)), \n                                    key=lambda i: float(scores.get(str(i), scores.get(i, 0))), \n                                    reverse=True)\n            return [docs[i] for i in ranked_indices[:self.rerank_top_n]]\n        except Exception as e:\n            print(f\"Reranking failed: {e}\")\n            return docs[:self.rerank_top_n]\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag in metadata or content with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for c in candidates:\n                lang = c.metadata.get(\"language\", \"\").lower()\n                # Accept if language matches or is unknown (for Python default)\n                if lang == requested_lang or (requested_lang == \"python\" and lang == \"unknown\"):\n                    filtered_candidates.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n            else:\n                # Fallback to original set if too few candidates remain\n                candidates = self.retriever.invoke(query_str)\n\n        # 2.5. Expand query if no good candidates found to increase recall\n        if self.expand_query and (not candidates or len(candidates) < 5):\n            def _expand_query(query: str) -> str:\n                base_expansion = \"google adk API usage example\"\n                if \"google adk\" not in query.lower():\n                    return query + \" \" + base_expansion\n                additions = [\"tutorial\", \"code sample\", \"example\", \"reference\"]\n                for add in additions:\n                    if add not in query.lower():\n                        return query + \" \" + add\n                return query\n\n            expanded_query = _expand_query(query_str)\n            if expanded_query and expanded_query != query_str:\n                candidates = self.retriever.invoke(expanded_query)\n=======\n        # 2. Cross-language filtering: detect requested language from query and filter candidates\n        requested_lang = None\n        lang_pattern = re.compile(r'\\b(python|go|java)\\b', re.I)\n        lang_match = lang_pattern.search(query_str)\n        if lang_match:\n            requested_lang = lang_match.group(1).lower()\n\n        # Filter candidates by language tag in metadata or content with fallback to preserve recall\n        if requested_lang:\n            filtered_candidates = []\n            for c in candidates:\n                lang = c.metadata.get(\"language\", \"\").lower()\n                # Accept if language matches or is unknown (for Python default)\n                if lang == requested_lang or (requested_lang == \"python\" and lang == \"unknown\"):\n                    filtered_candidates.append(c)\n            # Relax filtering if too few candidates remain to preserve recall\n            if filtered_candidates and len(filtered_candidates) >= max(3, self.rerank_top_n):\n                candidates = filtered_candidates\n            else:\n                # Fallback to original set if too few candidates remain\n                candidates = self.retriever.invoke(query_str)\n\n        # 2.5. Expand query if no good candidates found to increase recall, with improved expansion logic\n        if self.expand_query and (not candidates or len(candidates) < 5):\n            def _expand_query(query: str) -> str:\n                base_expansion = \"google adk API usage example\"\n                lower_query = query.lower()\n                if \"google adk\" not in lower_query:\n                    return query + \" \" + base_expansion\n                additions = [\"tutorial\", \"code sample\", \"example\", \"reference\"]\n                for add in additions:\n                    if add not in lower_query:\n                        return query + \" \" + add\n                return query\n\n            expanded_query = _expand_query(query_str)\n            if expanded_query and expanded_query != query_str:\n                candidates = self.retriever.invoke(expanded_query)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\"\n            \"6. When quoting code snippets, explicitly label the language for clarity.\\n\"\n            \"7. Use XML-style tags to separate and identify sources clearly.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n=======\n        # 5. Generation (Strict Grounding)\n        prompt = (\n            \"You are a technical expert on Google ADK. Answer the user's question STRICTLY using the provided context. \"\n            \"Follow these rules:\\n\"\n            \"1. If the answer is not in the context, explicitly state 'I don't know from the provided documentation'.\\n\"\n            \"2. When mentioning API classes or methods, use the EXACT names found in the context.\\n\"\n            \"3. Use the 'Quote then Explain' pattern: first quote the relevant doc/code, then provide your explanation.\\n\"\n            \"4. If multiple languages are available (Python, Go, Java), only provide the one requested by the user. If none requested, default to Python but mention others exist.\\n\"\n            \"5. Clearly indicate the programming language of any code snippet you quote.\\n\"\n            \"6. When quoting code snippets, explicitly label the language for clarity.\\n\"\n            \"7. Use XML-style tags to separate and identify sources clearly.\\n\\n\"\n            f\"Context:\\n{context_block}\\n\\n\"\n            f\"Question: {query_str}\\n\\n\"\n            \"Answer:\"\n        )\n        \n        try:\n            res = self.llm.invoke(prompt)\n        except Exception as e:\n            print(f\"LLM generation failed: {e}\")\n            return {\"answer\": \"I don't know from the provided documentation\", \"contexts\": final_contexts}\n        finally:\n            gc.collect()\n        \n        return {\"answer\": res.content, \"contexts\": final_contexts}\n# EVOLVE-BLOCK-END\n>>>>>>> REPLACE"]}}, "artifacts_json": "{\"raw_scores\": [0.305, 0.48000000000000004, 0.79375, 0.6937500000000001, 0.7589285714285714, 0.6089285714285715, 0.78125, 0.6714285714285715, 0.5666666666666667, 0.6041666666666666], \"error_details\": [{\"sample\": 3, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 11: name 'get_time' is not defined\\\", \\\"Instantiation Error on line 18: name 'get_time' is not defined\\\"]\", \"bad_code\": \"def get_weather(city: str) -> dict:\\n    \\\"\\\"\\\"Retrieves weather for a city.\\\"\\\"\\\"\\n    return {\\\"status\\\": \\\"success\\\", \\\"temperature\\\": \\\"25\\u00b0C\\\"}\\n\\n# Core abstractions: wrap a function as a tool.\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\\\"time\\\": \\\"12:00\\\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\\\"get_time\\\")\\n\\nfrom google.adk.tools import FunctionTool, ToolContext\\n\\ndef get_time(tool_context: ToolContext) -> dict:\\n    return {\\\"time\\\": \\\"12:00\\\"}\\n\\ntime_tool = FunctionTool(func=get_time, name=\\\"get_time\\\")\"}, {\"sample\": 5, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 4: cannot import name 'InvocationContext' from 'google.adk' (/home/erick/repo/google_adk_chatbot/venv/lib/python3.13/site-packages/google/adk/__init__.py)\\\"]\", \"bad_code\": \"# Python\\n\\nfrom typing import AsyncGenerator\\nfrom google.adk import InvocationContext, Event\\nfrom google.adk.agents import Agent\\n\\nclass RoutingCustomAgent(Agent):\\n    def __init__(self, weather_agent: Agent, news_agent: Agent):\\n        super().__init__()\\n        self.weather_agent = weather_agent\\n        self.news_agent = news_agent\\n\\n    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:\\n        # Access the session state dictionary\\n        state = ctx.session.state\\n\\n        # Example: route based on a 'topic' key in session state\\n        topic = state.get('topic')\\n\\n        if topic == 'weather':\\n            # Delegate to weather_agent and yield its events\\n            async for event in self.weather_agent.run_async(ctx):\\n                yield event\\n        elif topic == 'news':\\n            # Delegate to news_agent and yield its events\\n            async for event in self.news_agent.run_async(ctx):\\n                yield event\\n        else:\\n            # Default behavior or fallback\\n            # For example, yield a simple event or raise an error\\n            yield Event.text(\\\"Sorry, I don't understand the topic.\\\")\"}, {\"sample\": 7, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 22: No module named 'google.adk.runtime'\\\", \\\"Import Error on line 29: No module named 'google.adk.runtime'\\\", \\\"Instantiation Error on line 24: name 'Runner' is not defined\\\", \\\"Instantiation Error on line 56: name 'Runner' is not defined\\\"]\", \"bad_code\": \"# Conceptual Code: Sequential Data Pipeline\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\n\\nvalidator = LlmAgent(name=\\\"ValidateInput\\\", instruction=\\\"Validate the input.\\\", output_key=\\\"validation_status\\\")\\nprocessor = LlmAgent(name=\\\"ProcessData\\\", instruction=\\\"Process data if {validation_status} is 'valid'.\\\", output_key=\\\"result\\\")\\nreporter = LlmAgent(name=\\\"ReportResult\\\", instruction=\\\"Report the result from {result}.\\\")\\n\\ndata_pipeline = SequentialAgent(\\n    name=\\\"DataPipeline\\\",\\n    sub_agents=[validator, processor, reporter]\\n)\\n\\n# Conceptual Example: Sequential Pipeline\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\n\\nstep1 = LlmAgent(name=\\\"Step1_Fetch\\\", output_key=\\\"data\\\") # Saves output to state['data']\\nstep2 = LlmAgent(name=\\\"Step2_Process\\\", instruction=\\\"Process data from {data}.\\\")\\n\\npipeline = SequentialAgent(name=\\\"MyPipeline\\\", sub_agents=[step1, step2])\\n# When pipeline runs, Step2 can access the state['data'] set by Step1.\\n\\nfrom google.adk.runtime import Runner\\n\\nrunner = Runner()\\nrunner.run(pipeline)\\n\\n# Python\\nfrom google.adk.agents import SequentialAgent, LlmAgent\\nfrom google.adk.runtime import Runner\\n\\n# Define three LlmAgents with output_key to pass data via shared state\\nvalidator = LlmAgent(\\n    name=\\\"ValidateInput\\\",\\n    instruction=\\\"Validate the input.\\\",\\n    output_key=\\\"validation_status\\\"\\n)\\n\\nprocessor = LlmAgent(\\n    name=\\\"ProcessData\\\",\\n    instruction=\\\"Process data if {validation_status} is 'valid'.\\\",\\n    output_key=\\\"result\\\"\\n)\\n\\nreporter = LlmAgent(\\n    name=\\\"ReportResult\\\",\\n    instruction=\\\"Report the result from {result}.\\\"\\n)\\n\\n# Create a SequentialAgent pipeline with the three sub_agents\\ndata_pipeline = SequentialAgent(\\n    name=\\\"DataPipeline\\\",\\n    sub_agents=[validator, processor, reporter]\\n)\\n\\n# Create a Runner and run the pipeline\\nrunner = Runner()\\nrunner.run(data_pipeline)\"}, {\"sample\": 8, \"type\": \"code_error\", \"message\": \"[\\\"Instantiation Error on line 17: name 'WriterAgent' is not defined\\\", \\\"Instantiation Error on line 35: name 'WriterAgent' is not defined\\\"]\", \"bad_code\": \"# Conceptual Code: Iterative Code Refinement\\nfrom google.adk.agents import LoopAgent, LlmAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckingAgent(BaseAgent):\\n    async def run(self, ctx: InvocationContext) -> AsyncGenerator[Event, EventActions]:\\n        # Check some condition in ctx.state\\n        if ctx.state.get(\\\"quality\\\") >= 0.9:\\n            # Signal to stop the loop early\\n            yield Event(\\\"CheckComplete\\\")\\n            return EventActions(escalate=True)\\n        yield Event(\\\"CheckIncomplete\\\")\\n        return EventActions()\\n\\nloop_agent = LoopAgent(\\n    sub_agents=[WriterAgent(), CriticAgent(), CheckingAgent()],\\n    max_iterations=10\\n)\\n\\nfrom google.adk.agents import LoopAgent, BaseAgent\\nfrom google.adk.events import Event, EventActions\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\n\\nclass CheckingAgent(BaseAgent):\\n    async def run(self, ctx: InvocationContext) -> AsyncGenerator[Event, EventActions]:\\n        if ctx.state.get(\\\"quality\\\") >= 0.9:\\n            yield Event(\\\"CheckComplete\\\")\\n            return EventActions(escalate=True)\\n        yield Event(\\\"CheckIncomplete\\\")\\n        return EventActions()\\n\\nloop_agent = LoopAgent(\\n    sub_agents=[WriterAgent(), CriticAgent(), CheckingAgent()],\\n    max_iterations=10\\n)\"}, {\"sample\": 9, \"type\": \"code_error\", \"message\": \"[\\\"Import Error on line 5: No module named 'google.adk.agents.events'\\\"]\", \"bad_code\": \"from google.adk.agents import BaseAgent, LlmAgent, LoopAgent, SequentialAgent\\nfrom google.adk.agents.invocation_context import InvocationContext\\nfrom typing import AsyncGenerator\\nfrom typing_extensions import override\\nfrom google.adk.agents.events import Event\\nimport logging\\n\\nlogger = logging.getLogger(__name__)\\n\\nclass StoryFlowAgent(BaseAgent):\\n    \\\"\\\"\\\"\\n    Custom agent for a story generation and refinement workflow.\\n\\n    This agent orchestrates a sequence of LLM agents to generate a story,\\n    critique it, revise it, check grammar and tone, and potentially\\n    regenerate the story if the tone is negative.\\n    \\\"\\\"\\\"\\n\\n    # Declare the agents passed during initialization as class attributes with type hints\\n    story_generator: LlmAgent\\n    tone_check: LlmAgent\\n    loop_agent: LoopAgent\\n\\n    model_config = {\\\"arbitrary_types_allowed\\\": True}\\n\\n    def __init__(\\n        self,\\n        story_generator: LlmAgent,\\n        tone_check: LlmAgent,\\n        loop_agent: LoopAgent,\\n        **kwargs,\\n    ):\\n        super().__init__(**kwargs)\\n        self.story_generator = story_generator\\n        self.tone_check = tone_check\\n        self.loop_agent = loop_agent\\n\\n        # Tell BaseAgent about the top-level agents this custom agent orchestrates\\n        self._top_level_agents = [story_generator, tone_check, loop_agent]\\n\\n    @override\\n    async def _run_async_impl(\\n        self, ctx: InvocationContext\\n    ) -> AsyncGenerator[Event, None]:\\n        \\\"\\\"\\\"\\n        Implements the custom orchestration logic for the story workflow.\\n        Uses the instance attributes assigned by Pydantic (e.g., self.story_generator).\\n        \\\"\\\"\\\"\\n        logger.info(f\\\"[{self.name}] Starting story generation workflow.\\\")\\n\\n        # 1. Initial Story Generation\\n        logger.info(f\\\"[{self.name}] Running StoryGenerator...\\\")\\n        async for event in self.story_generator.run_async(ctx):\\n            logger.info(f\\\"[{self.name}] Event from StoryGenerator: {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n            yield event\\n\\n        # Check if story was generated before proceeding\\n        if \\\"current_story\\\" not in ctx.session.state or not ctx.session.state[\\\"current_story\\\"]:\\n            logger.error(f\\\"[{self.name}] Failed to generate initial story. Aborting workflow.\\\")\\n            return  # Stop processing if initial story failed\\n\\n        # 2. Tone Check and possible regeneration loop\\n        while True:\\n            logger.info(f\\\"[{self.name}] Running ToneCheck...\\\")\\n            async for event in self.tone_check.run_async(ctx):\\n                logger.info(f\\\"[{self.name}] Event from ToneCheck: {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n                yield event\\n\\n            tone = ctx.session.state.get(\\\"tone\\\", \\\"neutral\\\")\\n            logger.info(f\\\"[{self.name}] Tone detected: {tone}\\\")\\n\\n            if tone.lower() == \\\"negative\\\":\\n                logger.info(f\\\"[{self.name}] Negative tone detected, regenerating story...\\\")\\n                async for event in self.story_generator.run_async(ctx):\\n                    logger.info(f\\\"[{self.name}] Event from StoryGenerator (regeneration): {event.model_dump_json(indent=2, exclude_none=True)}\\\")\\n                    yield event\\n            else:\\n                logger.info(f\\\"[{self.name}] Tone acceptable, ending workflow.\\\")\\n                break\"}]}", "artifact_dir": null, "embedding": null}