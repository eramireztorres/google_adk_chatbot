{"id": "36bb4ec0-a389-4376-be11-e056352fe131", "code": "import os\nimport time\nfrom typing import Dict, Any\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n        return _rag_system_cache.query(query)\n    except Exception as e:\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings\nfrom llama_index.llms.openai import OpenAI\nfrom llama_index.embeddings.openai import OpenAIEmbedding\nfrom llama_index.core.node_parser import SemanticSplitterNodeParser\nfrom llama_index.core.postprocessor import LLMRerank\nfrom llama_index.core.query_engine import RetrieverQueryEngine\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.index = None\n        self.query_engine = None\n        self._initialized = False\n        self._initialize_system()\n\n    def _initialize_system(self):\n        if self._initialized:\n            return\n        Settings.llm = OpenAI(model=\"gpt-4.1-mini\", temperature=0.0)\n        Settings.embed_model = OpenAIEmbedding(model=\"text-embedding-3-small\")\n        Settings.chunk_size = 512\n        Settings.chunk_overlap = 128\n\n        try:\n            probe_vec = Settings.embed_model.get_text_embedding(\"probe\")\n            if not probe_vec or len(probe_vec) == 0:\n                raise ValueError(\"embedding probe returned empty vector\")\n        except Exception as e:\n            raise RuntimeError(f\"embedding_probe_failed: {e}\")\n\n        reader = SimpleDirectoryReader(\n            input_dir=self.docs_dir,\n            recursive=True,\n            required_exts=[\".md\", \".txt\"],\n        )\n        documents = reader.load_data()\n        try:\n            splitter = SemanticSplitterNodeParser(chunk_size=512, chunk_overlap=128)\n            nodes = splitter.get_nodes_from_documents(documents)\n        except Exception:\n            # fallback to sentence splitter\n            from llama_index.core.node_parser import SentenceSplitter\n            splitter = SentenceSplitter(chunk_size=512, chunk_overlap=128)\n            nodes = splitter.get_nodes_from_documents(documents)\n\n        self.index = VectorStoreIndex(nodes)\n        retriever = self.index.as_retriever(similarity_top_k=3)\n        reranker = LLMRerank(top_n=2)\n        self.query_engine = RetrieverQueryEngine(\n            retriever,\n            node_postprocessors=[reranker],\n        )\n        self._initialized = True\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        response = self.query_engine.query(query_str)\n        contexts = [node.node.get_content() for node in response.source_nodes]\n        return {\"answer\": str(response), \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "b7d46579-cfee-40d2-928b-846ac22c8d89", "generation": 1, "timestamp": 1767452918.0646887, "iteration_found": 2, "metrics": {"combined_score": 0.731369281841649, "metrics": {"avg_score": 0.7744097222222223, "time_penalty": 0.043040440380573274, "avg_latency": 9.304044038057327, "framework_id": 0.0, "complexity": 40.0, "diversity": 0.0, "performance": 0.731369281841649}, "framework_id": 0.0, "complexity": 40.0, "artifacts": {"critique": "Framework: Llama\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low answer_relevancy (0.17): The score is 0.17 because the response contains multiple irrelevant statements about the get_current_time function's behavior and return value, which do not directly address the request to provide the code defining the get_current_time tool and the root_agent from the ADK quickstart. However, it may include some relevant information or partial code snippets, preventing the score from being zero.\nQuery: 'Give the Python example of a Function Tool with required parameters city and unit from the ADK function tools documentation.' -> Low answer_relevancy (0.67): The score is 0.67 because while the response includes some relevant Python code for a Function Tool with specified parameters, it also contains unrelated statements about weather reports and function return structures, which reduce overall relevance.\nMetric faithfulness failed: Could not parse response content as the length limit was reached - CompletionUsage(completion_tokens=32768, prompt_tokens=1004, total_tokens=33772, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0))\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low answer_relevancy (0.00): The score is 0.00 because the provided output contains no relevant Python example demonstrating the registration of a before_model callback in an LlmAgent, and instead includes only unrelated code descriptions and explanations.\nQuery: 'From the MCP tools documentation, provide the Python agent.py sample that connects to a local filesystem MCP server started via npx and exposes its tools through MCPToolset.' -> Low contextual_recall (0.00): The score is 0.00 because the original expected output contains detailed code and comments that are not supported by the retrieval context, which only includes import statements and path construction without specific code snippets or instructions."}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 49 lines with 55 lines", "parent_metrics": {"combined_score": 0.548016796331385, "metrics": {"avg_score": 0.6179978354978355, "time_penalty": 0.0699810391664505, "avg_latency": 11.99810391664505, "framework_id": 0.0, "complexity": 37.4, "diversity": 0.0, "performance": 0.548016796331385}, "framework_id": 0.0, "complexity": 37.4, "artifacts": {"critique": "Framework: Llama\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low answer_relevancy (0.50): The score is 0.50 because some irrelevant statements about importing modules and agent configuration are included, which do not directly address defining the get_current_time tool and root_agent. However, the core code is present, so the score isn't lower.\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low contextual_recall (0.20): The score is 0.20 because the expected output's code and description align with node 1 in the retrieval context, which involves defining tools and including a 'get_current_time' tool, but the rest of the output contains unrelated details, leading to a low relevance score.\nQuery: 'Give the Python example of a Function Tool with required parameters city and unit from the ADK function tools documentation.' -> Low answer_relevancy (0.40): The score is 0.40 because the output contains multiple irrelevant statements about docstrings, placeholders, and return values that do not directly address providing a Python example of the Function Tool with 'city' and 'unit' parameters, thus limiting its relevance.\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low faithfulness (0.00): The score is 0.00 because the actual output references callback functions named 'my_before_model_logic' and 'myBeforeModelLogic', which are not mentioned in the retrieval context that specifies 'onBeforeModel' and 'myBeforeModelLogic'. Additionally, it describes an 'agent' with specific attributes and initialization details not present in the context, leading to contradictions.\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low answer_relevancy (0.57): The score is 0.57 because the output contains some irrelevant statements about printing messages and function logic that do not directly address registering a before_model callback, but it also includes relevant code snippets, so the score isn't lower."}}, "island": 0}, "prompts": {"diff_user": {"system": "You are an expert Python engineer specialized in LlamaIndex RAG.\nYour job is to EVOLVE a WORKING, RUNNABLE `RAGSystem` for querying a Markdown docs directory.\n\n========================\nCRITICAL CONSTRAINTS\n========================\n1) Output ONLY valid Python code (no markdown fences).\n2) The code must be self-contained within the EVOLVE-BLOCK (imports + class RAGSystem).\n3) Use gpt-4.1-mini inside the RAG code.\n4) LlamaIndex only. Do NOT use LangChain/LangGraph or Agno.\n5) Any symbol you reference MUST be imported in the EVOLVE block using allowed imports.\n\n========================\nMUTATION STRATEGY\n========================\nAlternate between these retrieval architectures across candidates:\n  A) RetrieverQueryEngine + LLMRerank\n  B) SubQuestionQueryEngine + QueryEngineTool\n  C) RouterQueryEngine + QueryEngineTool\nIf you stay with the same architecture, you must change chunking method.\nAvoid external vector stores unless dependencies are installed; fall back to VectorStoreIndex.\n\n========================\nALLOWED IMPORTS\n========================\n  from llama_index.core import Settings, VectorStoreIndex, SimpleDirectoryReader\n  from llama_index.llms.openai import OpenAI\n  from llama_index.embeddings.openai import OpenAIEmbedding\n  from llama_index.core.node_parser import SentenceSplitter, SemanticSplitterNodeParser\n  from llama_index.core.workflow import Workflow, StartEvent, StopEvent, step, Context\n  from llama_index.core.schema import NodeWithScore\n  from llama_index.core.query_engine import SubQuestionQueryEngine, RouterQueryEngine, RetrieverQueryEngine\n  from llama_index.core.postprocessor import LLMRerank\n  from llama_index.core.tools import QueryEngineTool\n\nREQUIRED INGESTION:\n  reader = SimpleDirectoryReader(input_dir=docs_dir, recursive=True, required_exts=[\".md\", \".txt\"])\n  documents = reader.load_data()\n\nCHUNKING METHODS (pick one per candidate):\n  - SentenceSplitter\n  - SemanticSplitterNodeParser (with try/except fallback)\n  - Document-based (VectorStoreIndex.from_documents)\n\nTOOL ROUTING (SAFE PATTERNS):\n  tool1 = QueryEngineTool.from_defaults(\n      query_engine=index.as_query_engine(similarity_top_k=3),\n      description=\"General documentation queries.\",\n  )\n  tool2 = QueryEngineTool.from_defaults(\n      query_engine=index.as_query_engine(similarity_top_k=6),\n      description=\"Broader context queries.\",\n  )\n\n  # SubQuestionQueryEngine\n  query_engine = SubQuestionQueryEngine.from_defaults(\n      query_engine_tools=[tool1, tool2]\n  )\n\n  # RouterQueryEngine\n  query_engine = RouterQueryEngine.from_defaults(\n      query_engine_tools=[tool1, tool2]\n  )\n\nWORKFLOW RAG (SAFE SKELETON):\n  class RetrieverEvent(Event):\n      nodes: list[NodeWithScore]\n\n  class RerankEvent(Event):\n      nodes: list[NodeWithScore]\n\n  class RAGWorkflow(Workflow):\n      @step\n      async def ingest(self, ctx: Context, ev: StartEvent) -> StopEvent | None:\n          dirname = ev.get(\"dirname\")\n          if not dirname:\n              return None\n          docs = SimpleDirectoryReader(dirname).load_data()\n          index = VectorStoreIndex.from_documents(docs)\n          return StopEvent(result=index)\n\n      @step\n      async def retrieve(self, ctx: Context, ev: StartEvent) -> RetrieverEvent | None:\n          query = ev.get(\"query\")\n          index = ev.get(\"index\")\n          if not query or index is None:\n              return None\n          retriever = index.as_retriever(similarity_top_k=2)\n          nodes = await retriever.aretrieve(query)\n          return RetrieverEvent(nodes=nodes)\n\n      @step\n      async def rerank(self, ctx: Context, ev: RetrieverEvent) -> RerankEvent:\n          ranker = LLMRerank(choice_batch_size=5, top_n=3)\n          new_nodes = ranker.postprocess_nodes(ev.nodes, query_str=ev.get(\"query\"))\n          return RerankEvent(nodes=new_nodes)\n\n      @step\n      async def synthesize(self, ctx: Context, ev: RerankEvent) -> StopEvent:\n          response = \" \".join([n.node.get_content() for n in ev.nodes])\n          return StopEvent(result=response)\n", "user": "# Current Program Information\n- Fitness: 0.5480\n- Feature coordinates: complexity=37.40, framework_id=0.00\n- Focus areas: - Fitness unchanged at 0.5480\n- Exploring complexity=37.40, framework_id=0.00 region of solution space\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: combined_score: 0.5480, metrics: {'avg_score': 0.6179978354978355, 'time_penalty': 0.0699810391664505, 'avg_latency': 11.99810391664505, 'framework_id': 0.0, 'complexity': 37.4, 'diversity': 0.0, 'performance': 0.548016796331385}, framework_id: 0.0000, complexity: 37.4000, artifacts: {'critique': \"Framework: Llama\\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low answer_relevancy (0.50): The score is 0.50 because some irrelevant statements about importing modules and agent configuration are included, which do not directly address defining the get_current_time tool and root_agent. However, the core code is present, so the score isn't lower.\\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low contextual_recall (0.20): The score is 0.20 because the expected output's code and description align with node 1 in the retrieval context, which involves defining tools and including a 'get_current_time' tool, but the rest of the output contains unrelated details, leading to a low relevance score.\\nQuery: 'Give the Python example of a Function Tool with required parameters city and unit from the ADK function tools documentation.' -> Low answer_relevancy (0.40): The score is 0.40 because the output contains multiple irrelevant statements about docstrings, placeholders, and return values that do not directly address providing a Python example of the Function Tool with 'city' and 'unit' parameters, thus limiting its relevance.\\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low faithfulness (0.00): The score is 0.00 because the actual output references callback functions named 'my_before_model_logic' and 'myBeforeModelLogic', which are not mentioned in the retrieval context that specifies 'onBeforeModel' and 'myBeforeModelLogic'. Additionally, it describes an 'agent' with specific attributes and initialization details not present in the context, leading to contradictions.\\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low answer_relevancy (0.57): The score is 0.57 because the output contains some irrelevant statements about printing messages and function logic that do not directly address registering a before_model callback, but it also includes relevant code snippets, so the score isn't lower.\"}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5480)\n```python\nimport os\nimport time\nfrom typing import Dict, Any\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n        return _rag_system_cache.query(query)\n    except Exception as e:\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings\nfrom llama_index.llms.openai import OpenAI\nfrom llama_index.embeddings.openai import OpenAIEmbedding\nfrom llama_index.core.node_parser import SentenceSplitter\nfrom llama_index.core.postprocessor import LLMRerank\nfrom llama_index.core.query_engine import RetrieverQueryEngine\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.index = None\n        self.query_engine = None\n        self._initialized = False\n        self._initialize_system()\n\n    def _initialize_system(self):\n        if self._initialized:\n            return\n        Settings.llm = OpenAI(model=\"gpt-4.1-mini\", temperature=0.0)\n        Settings.embed_model = OpenAIEmbedding(model=\"text-embedding-3-small\")\n        Settings.chunk_size = 400\n        Settings.chunk_overlap = 80\n\n        try:\n            probe_vec = Settings.embed_model.get_text_embedding(\"probe\")\n            if not probe_vec or len(probe_vec) == 0:\n                raise ValueError(\"embedding probe returned empty vector\")\n        except Exception as e:\n            raise RuntimeError(f\"embedding_probe_failed: {e}\")\n\n        reader = SimpleDirectoryReader(\n            input_dir=self.docs_dir,\n            recursive=True,\n            required_exts=[\".md\", \".txt\"],\n        )\n        documents = reader.load_data()\n        splitter = SentenceSplitter(chunk_size=400, chunk_overlap=80)\n        nodes = splitter.get_nodes_from_documents(documents)\n\n        self.index = VectorStoreIndex(nodes)\n        retriever = self.index.as_retriever(similarity_top_k=6)\n        reranker = LLMRerank(top_n=3)\n        self.query_engine = RetrieverQueryEngine(\n            retriever,\n            node_postprocessors=[reranker],\n        )\n        self._initialized = True\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        response = self.query_engine.query(query_str)\n        contexts = [node.node.get_content() for node in response.source_nodes]\n        return {\"answer\": str(response), \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on combined_score (0.5480), Performs well on metrics ({'avg_score': 0.6179978354978355, 'time_penalty': 0.0699810391664505, 'avg_latency': 11.99810391664505, 'framework_id': 0.0, 'complexity': 37.4, 'diversity': 0.0, 'performance': 0.548016796331385}), Performs well on framework_id (0.0000), Performs well on complexity (37.4000), Performs well on artifacts ({'critique': \"Framework: Llama\\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low answer_relevancy (0.50): The score is 0.50 because some irrelevant statements about importing modules and agent configuration are included, which do not directly address defining the get_current_time tool and root_agent. However, the core code is present, so the score isn't lower.\\nQuery: 'Provide the Python code from the ADK quickstart that defines the get_current_time tool and the root_agent.' -> Low contextual_recall (0.20): The score is 0.20 because the expected output's code and description align with node 1 in the retrieval context, which involves defining tools and including a 'get_current_time' tool, but the rest of the output contains unrelated details, leading to a low relevance score.\\nQuery: 'Give the Python example of a Function Tool with required parameters city and unit from the ADK function tools documentation.' -> Low answer_relevancy (0.40): The score is 0.40 because the output contains multiple irrelevant statements about docstrings, placeholders, and return values that do not directly address providing a Python example of the Function Tool with 'city' and 'unit' parameters, thus limiting its relevance.\\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low faithfulness (0.00): The score is 0.00 because the actual output references callback functions named 'my_before_model_logic' and 'myBeforeModelLogic', which are not mentioned in the retrieval context that specifies 'onBeforeModel' and 'myBeforeModelLogic'. Additionally, it describes an 'agent' with specific attributes and initialization details not present in the context, leading to contradictions.\\nQuery: 'Show the Python example that registers a before_model callback in an LlmAgent.' -> Low answer_relevancy (0.57): The score is 0.57 because the output contains some irrelevant statements about printing messages and function logic that do not directly address registering a before_model callback, but it also includes relevant code snippets, so the score isn't lower.\"})\n\n\n\n# Current Program\n```python\nimport os\nimport time\nfrom typing import Dict, Any\n\n# --- BOILERPLATE: DO NOT EVOLVE ---\n_rag_system_cache = None\n\ndef evaluate_rag(docs_path: str, query: str) -> Dict[str, Any]:\n    global _rag_system_cache\n    try:\n        if _rag_system_cache is None or _rag_system_cache.docs_dir != docs_path:\n            _rag_system_cache = RAGSystem(docs_path)\n        return _rag_system_cache.query(query)\n    except Exception as e:\n        return {\"answer\": f\"Error: {str(e)}\", \"contexts\": []}\n# --- END BOILERPLATE ---\n\n# EVOLVE-BLOCK-START\nfrom llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings\nfrom llama_index.llms.openai import OpenAI\nfrom llama_index.embeddings.openai import OpenAIEmbedding\nfrom llama_index.core.node_parser import SentenceSplitter\nfrom llama_index.core.postprocessor import LLMRerank\nfrom llama_index.core.query_engine import RetrieverQueryEngine\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.index = None\n        self.query_engine = None\n        self._initialized = False\n        self._initialize_system()\n\n    def _initialize_system(self):\n        if self._initialized:\n            return\n        Settings.llm = OpenAI(model=\"gpt-4.1-mini\", temperature=0.0)\n        Settings.embed_model = OpenAIEmbedding(model=\"text-embedding-3-small\")\n        Settings.chunk_size = 400\n        Settings.chunk_overlap = 80\n\n        try:\n            probe_vec = Settings.embed_model.get_text_embedding(\"probe\")\n            if not probe_vec or len(probe_vec) == 0:\n                raise ValueError(\"embedding probe returned empty vector\")\n        except Exception as e:\n            raise RuntimeError(f\"embedding_probe_failed: {e}\")\n\n        reader = SimpleDirectoryReader(\n            input_dir=self.docs_dir,\n            recursive=True,\n            required_exts=[\".md\", \".txt\"],\n        )\n        documents = reader.load_data()\n        splitter = SentenceSplitter(chunk_size=400, chunk_overlap=80)\n        nodes = splitter.get_nodes_from_documents(documents)\n\n        self.index = VectorStoreIndex(nodes)\n        retriever = self.index.as_retriever(similarity_top_k=6)\n        reranker = LLMRerank(top_n=3)\n        self.query_engine = RetrieverQueryEngine(\n            retriever,\n            node_postprocessors=[reranker],\n        )\n        self._initialized = True\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        response = self.query_engine.query(query_str)\n        contexts = [node.node.get_content() for node in response.source_nodes]\n        return {\"answer\": str(response), \"contexts\": contexts}\n# EVOLVE-BLOCK-END\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: score, complexity, framework_id\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nfrom llama_index.core.node_parser import SentenceSplitter\nfrom llama_index.core.postprocessor import LLMRerank\nfrom llama_index.core.query_engine import RetrieverQueryEngine\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.index = None\n        self.query_engine = None\n        self._initialized = False\n        self._initialize_system()\n\n    def _initialize_system(self):\n        if self._initialized:\n            return\n        Settings.llm = OpenAI(model=\"gpt-4.1-mini\", temperature=0.0)\n        Settings.embed_model = OpenAIEmbedding(model=\"text-embedding-3-small\")\n        Settings.chunk_size = 400\n        Settings.chunk_overlap = 80\n\n        try:\n            probe_vec = Settings.embed_model.get_text_embedding(\"probe\")\n            if not probe_vec or len(probe_vec) == 0:\n                raise ValueError(\"embedding probe returned empty vector\")\n        except Exception as e:\n            raise RuntimeError(f\"embedding_probe_failed: {e}\")\n\n        reader = SimpleDirectoryReader(\n            input_dir=self.docs_dir,\n            recursive=True,\n            required_exts=[\".md\", \".txt\"],\n        )\n        documents = reader.load_data()\n        splitter = SentenceSplitter(chunk_size=400, chunk_overlap=80)\n        nodes = splitter.get_nodes_from_documents(documents)\n\n        self.index = VectorStoreIndex(nodes)\n        retriever = self.index.as_retriever(similarity_top_k=6)\n        reranker = LLMRerank(top_n=3)\n        self.query_engine = RetrieverQueryEngine(\n            retriever,\n            node_postprocessors=[reranker],\n        )\n        self._initialized = True\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        response = self.query_engine.query(query_str)\n        contexts = [node.node.get_content() for node in response.source_nodes]\n        return {\"answer\": str(response), \"contexts\": contexts}\n=======\nfrom llama_index.core.node_parser import SemanticSplitterNodeParser\nfrom llama_index.core.postprocessor import LLMRerank\nfrom llama_index.core.query_engine import RetrieverQueryEngine\n\nclass RAGSystem:\n    def __init__(self, docs_dir: str):\n        self.docs_dir = docs_dir\n        self.index = None\n        self.query_engine = None\n        self._initialized = False\n        self._initialize_system()\n\n    def _initialize_system(self):\n        if self._initialized:\n            return\n        Settings.llm = OpenAI(model=\"gpt-4.1-mini\", temperature=0.0)\n        Settings.embed_model = OpenAIEmbedding(model=\"text-embedding-3-small\")\n        Settings.chunk_size = 512\n        Settings.chunk_overlap = 128\n\n        try:\n            probe_vec = Settings.embed_model.get_text_embedding(\"probe\")\n            if not probe_vec or len(probe_vec) == 0:\n                raise ValueError(\"embedding probe returned empty vector\")\n        except Exception as e:\n            raise RuntimeError(f\"embedding_probe_failed: {e}\")\n\n        reader = SimpleDirectoryReader(\n            input_dir=self.docs_dir,\n            recursive=True,\n            required_exts=[\".md\", \".txt\"],\n        )\n        documents = reader.load_data()\n        try:\n            splitter = SemanticSplitterNodeParser(chunk_size=512, chunk_overlap=128)\n            nodes = splitter.get_nodes_from_documents(documents)\n        except Exception:\n            # fallback to sentence splitter\n            from llama_index.core.node_parser import SentenceSplitter\n            splitter = SentenceSplitter(chunk_size=512, chunk_overlap=128)\n            nodes = splitter.get_nodes_from_documents(documents)\n\n        self.index = VectorStoreIndex(nodes)\n        retriever = self.index.as_retriever(similarity_top_k=3)\n        reranker = LLMRerank(top_n=2)\n        self.query_engine = RetrieverQueryEngine(\n            retriever,\n            node_postprocessors=[reranker],\n        )\n        self._initialized = True\n\n    def query(self, query_str: str) -> Dict[str, Any]:\n        response = self.query_engine.query(query_str)\n        contexts = [node.node.get_content() for node in response.source_nodes]\n        return {\"answer\": str(response), \"contexts\": contexts}\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}